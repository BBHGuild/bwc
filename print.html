<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Blockchain Weakness Classification (BWC)</title>
        <meta name="robots" content="noindex">


        <!-- Google tag (gtag.js) -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-HDV7VPQ8R3"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());

          gtag('config', 'G-HDV7VPQ8R3');
        </script>

        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive taxonomy for EVM vulnerabilities, mapped to 10 years of incident analysis (2016-2026).">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <!-- Twitter Card data -->
        <meta name="twitter:card" content="summary_large_image">
        <meta name="twitter:title" content="Blockchain Weakness Classification (BWC)">
        <meta name="twitter:description" content="A comprehensive taxonomy for EVM vulnerabilities, mapped to 10 years of incident analysis (2016-2026).">
        <meta name="twitter:image" content="https://bbhguild.github.io/bwc/skills/bounty-hunting/references/assets/BWC-2021-2026.png">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">
        <link rel="stylesheet" href="theme/collapsible.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Blockchain Weakness Classification (BWC)</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/BBHGuild/bwc/" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://x.com/BBHGuild/" title="X (Twitter)" aria-label="X (Twitter)">
                            <i id="x-link" class="fa fa-twitter"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="content-wrap">
                            <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="blockchain-weakness-classification-bwc"><a class="header" href="#blockchain-weakness-classification-bwc">Blockchain Weakness Classification (BWC)</a></h1>
<p>A taxonomy for classifying smart contract vulnerabilities.</p>
<p>Last Update: Feb 2 2026</p>
<p>Authors: <a href="https://x.com/BBHGuild">@BBHGuild</a></p>
<h2 id="bwc-top-11"><a class="header" href="#bwc-top-11">BWC Top 11</a></h2>
<p><a href="skills/bounty-hunting/references/assets/BWC-2016-2021.png"><img src="skills/bounty-hunting/references/assets/BWC-2016-2021.png" alt="BWC Evolution Chart (2016-2021)" /></a>
<a href="skills/bounty-hunting/references/assets/BWC-2021-2026.png"><img src="skills/bounty-hunting/references/assets/BWC-2021-2026.png" alt="BWC Evolution Chart (2021-2026)" /></a></p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Blockchain Weakness Classification</th><th style="text-align: left"></th><th style="text-align: left"></th><th style="text-align: left">Description</th><th style="text-align: left">Exploit Methods</th><th style="text-align: left">Mitigation</th></tr></thead><tbody>
<tr><td style="text-align: left"><h1 id="bwc-1-ecosystem--off-chain-risks"><a class="header" href="#bwc-1-ecosystem--off-chain-risks">BWC 1: Ecosystem &amp; Off-Chain Risks</a></h1></td><td style="text-align: left"><h2 id="bwc-11-foundational-design-flaws-trustlessness"><a class="header" href="#bwc-11-foundational-design-flaws-trustlessness">BWC 1.1: Foundational Design Flaws (Trustlessness)</a></h2></td><td style="text-align: left"><h3 id="bwc-111-indispensable-intermediaries"><a class="header" href="#bwc-111-indispensable-intermediaries">BWC 1.1.1: Indispensable Intermediaries</a></h3></td><td style="text-align: left">The system violates the "No Indispensable Intermediaries" law. It relies on specific actors (sequencers, relayers, provers, admin keys) that cannot be replaced by an ordinary participant. If these actors misbehave or disappear, the system halts or censors.</td><td style="text-align: left"><li><strong>Mandatory Gatekeepers:</strong> Requiring a whitelisted relayer to execute transactions.</li><li><strong>Liveness Failure:</strong> The system fails the <strong>"Walkaway Test"</strong>â€”if the team's node dies, the chain stops.</li><li><strong>Admin Keys:</strong> Multisigs with the power to override consensus or pause the chain indefinitely.</li></td><td style="text-align: left"><li>Ensure <strong>permissionless participation</strong> for all infrastructure roles.</li><li>Design for <strong>redundancy</strong>; any honest actor should be able to advance the state.</li><li>Remove "Training Wheels" (admin keys) as the system matures.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-112-barriers-to-verification-the-specialist-gap"><a class="header" href="#bwc-112-barriers-to-verification-the-specialist-gap">BWC 1.1.2: Barriers to Verification (The Specialist Gap)</a></h3></td><td style="text-align: left">The system is theoretically open but practically closed due to excessive complexity or resource requirements. This violates the "Accessibility" principle, creating a class system where verification is a privilege for specialists, forcing users to "trust the dashboard."</td><td style="text-align: left"><li><strong>Hardware Exclusion:</strong> Verifier nodes requiring enterprise-grade RAM/Storage, pricing out community auditors.</li><li><strong>Closed Source/Obfuscation:</strong> Proprietary code prevents independent reasoning about state validity.</li></td><td style="text-align: left"><li>Prioritize <strong>Light Clients</strong> that can run on consumer hardware.</li><li>Ensure all components are <strong>Free Open Source Software (FOSS)</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-113-reliance-on-critical-secrets"><a class="header" href="#bwc-113-reliance-on-critical-secrets">BWC 1.1.3: Reliance on Critical Secrets</a></h3></td><td style="text-align: left">The system violates the "No Critical Secrets" law. It relies on private information (mempools, off-chain order books, server-side keys) held by a single actor to function or determine state transitions.</td><td style="text-align: left"><li><strong>Mempool Manipulation:</strong> A centralized sequencer exploits its private view of pending transactions to extract MEV or censor users.</li><li><strong>Opaque Execution:</strong> Transaction outcomes depend on off-chain data that is not cryptographically committed to the chain.</li></td><td style="text-align: left"><li><strong>No Private State:</strong> All data required to verify a transition must be public.</li><li>Use <strong>Threshold Encryption</strong> to protect pre-execution state without centralizing trust.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-114-forced-delegation-loss-of-sovereignty"><a class="header" href="#bwc-114-forced-delegation-loss-of-sovereignty">BWC 1.1.4: Forced Delegation (Loss of Sovereignty)</a></h3></td><td style="text-align: left">The system replaces <strong>Delegation</strong> (optional convenience) with <strong>Dependence</strong> (mandatory reliance). Users cannot interact with the protocol directly but <em>must</em> route through a specific UI, API, or relayer that acts as a landlord.</td><td style="text-align: left"><li><strong>Interface Censorship:</strong> The protocol is open, but the only UI is hosted and blocklisted (e.g., Tornado Cash UI).</li><li><strong>Gateway Lock-in:</strong> Users sign "intents" that can only be solved by a closed set of solvers.</li></td><td style="text-align: left"><li>Ensure <strong>direct contract interaction</strong> is always possible.</li><li>Build <strong>Client Diversity</strong> to prevent interface-level capture.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-115-lack-of-credible-neutrality"><a class="header" href="#bwc-115-lack-of-credible-neutrality">BWC 1.1.5: Lack of Credible Neutrality</a></h3></td><td style="text-align: left">The base layer discriminates against specific users or use cases. Instead of "math and consensus," the protocol enforces policy, becoming a "Platform" rather than a neutral "Protocol."</td><td style="text-align: left"><li><strong>Protocol-Level Censorship:</strong> Validators filtering transactions based on real-world identity or geography.</li><li><strong>Governance Capture:</strong> A token distribution that allows a small oligopoly to change the rules arbitrarily.</li></td><td style="text-align: left"><li><strong>Minimize Governance:</strong> Governance should be minimized or removed ("Ossification") for base layers.</li><li><strong>Blind Execution:</strong> The protocol should process any valid transaction regardless of origin.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-116-unverifiable-outcomes"><a class="header" href="#bwc-116-unverifiable-outcomes">BWC 1.1.6: Unverifiable Outcomes</a></h3></td><td style="text-align: left">The system violates the "No Unverifiable Outcomes" law. Effects on the state cannot be strictly reproduced from public data, requiring "Blind Trust" in an oracle or multisig.</td><td style="text-align: left"><li><strong>Multisig Bridges:</strong> State updates based solely on "7 of 10 people signed this," with no cryptographic proof of the source event.</li><li><strong>Opaque Upgrades:</strong> Logic changes instantly via admin key without a timelock or user opt-out.</li></td><td style="text-align: left"><li>Use <strong>Validity Proofs (ZK)</strong> or Fraud Proofs to replace human attestation.</li><li>Ensure <strong>Data Availability (DA)</strong> so state can always be reconstructed.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-117-user-disempowerment--extractive-design-corposlop"><a class="header" href="#bwc-117-user-disempowerment--extractive-design-corposlop">BWC 1.1.7: User Disempowerment &amp; Extractive Design ("Corposlop")</a></h3></td><td style="text-align: left">The system prioritizes <strong>corporate metrics</strong> (market cap, engagement) over user sovereignty. It uses "corporate optimization power" and a "respectable aura" to mask behavior that extracts value from users rather than empowering them. This manifests in four key ways:<br><br>1. <strong>Attention &amp; Dopamine Extraction:</strong> Hijacking attention for short-term engagement (addiction).<br>2. <strong>Surveillance &amp; Data Commodification:</strong> Needless data collection to create sellable assets.<br>3. <strong>Walled Gardens:</strong> Preventing exit or interoperability (Monopolistic Lock-in).<br>4. <strong>Predatory Financialization:</strong> Marketing high-risk gambling as "investing" (Gamblification).</td><td style="text-align: left"><li><strong>Gamified Addiction:</strong> Using "loot box" mechanics, streaks, or manipulative notifications to force daily interaction without utility.</li><li><strong>Wallet Doxing:</strong> RPCs or front-ends that link wallet addresses to real-world identities/IPs without consent.</li><li><strong>Vendor Lock-in:</strong> Proprietary standards or bridges that prevent users from exporting keys or moving assets to competitors.</li><li><strong>Default Leverage:</strong> UIs that default to high-risk settings (e.g., 50x leverage) to maximize liquidation fees at the expense of user solvency.</li></td><td style="text-align: left"><li><strong>Sovereign Tools:</strong> Build privacy-preserving, local-first applications where the user owns the data.</li><li><strong>User-Controlled Algorithms:</strong> Allow users to choose their own content filters and sorting logic.</li><li><strong>Credible Exit:</strong> Users must always be able to withdraw assets/data to a neutral standard (e.g., raw ETH, raw Text).</li><li><strong>Wealth-Building Design:</strong> Focus on tools that encourage saving and utility rather than impulse and speculation.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-12-identity--key-management-failures"><a class="header" href="#bwc-12-identity--key-management-failures">BWC 1.2: Identity &amp; Key Management Failures</a></h2></td><td style="text-align: left"><h3 id="bwc-121-compromised-deviceos"><a class="header" href="#bwc-121-compromised-deviceos">BWC 1.2.1: Compromised Device/OS</a></h3></td><td style="text-align: left">Vulnerabilities in <strong>user devices or operating systems</strong> leading to private key theft, session hijacking, or malicious transaction approvals.</td><td style="text-align: left"><li>Infecting a device with <strong>malware</strong> via malicious downloads or phishing links.</li><li>Exploiting <strong>unpatched OS vulnerabilities</strong> to gain root access.</li></td><td style="text-align: left"><li>Use dedicated, <strong>air-gapped devices</strong> for signing critical transactions.</li><li>Keep all software, including <strong>OS and browser, up-to-date</strong>.</li><li>Employ <strong>hardware wallets</strong> to isolate keys from general-purpose devices.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-122-private-key-leakage"><a class="header" href="#bwc-122-private-key-leakage">BWC 1.2.2: Private Key Leakage</a></h3></td><td style="text-align: left"><strong>Accidental or intentional exposure</strong> of private keys, granting unauthorized access to funds.</td><td style="text-align: left"><li><strong>Hardcoding keys</strong> in public code (e.g., GitHub).</li><li><strong>Phishing attacks</strong> tricking users into revealing their seed phrase.</li><li>Insecurely <strong>storing keys in plaintext</strong> on a compromised server.</li></td><td style="text-align: left"><li>Store keys in <strong>hardware security modules (HSMs)</strong> or <strong>hardware wallets</strong>.</li><li><strong>Never store seed phrases digitally</strong>.</li><li>Use <strong>multi-signature (multisig) wallets</strong> to require multiple keys for a transaction.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-123-insider-threat"><a class="header" href="#bwc-123-insider-threat">BWC 1.2.3: Insider Threat</a></h3></td><td style="text-align: left">Current or former employees, contractors, or partners intentionally <strong>misusing their authorized access</strong> to compromise a system.</td><td style="text-align: left"><li>A <strong>rogue developer</strong> inserting a backdoor into a smart contract.</li><li>A <strong>disgruntled employee</strong> stealing funds from protocol-owned wallets.</li></td><td style="text-align: left"><li>Implement strict <strong>access controls</strong> and the principle of <strong>least privilege</strong>.</li><li>Use <strong>timelocks</strong> for critical administrative actions.</li><li>Conduct thorough <strong>background checks</strong> on individuals in sensitive roles.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-124-wrench-attacks"><a class="header" href="#bwc-124-wrench-attacks">BWC 1.2.4: Wrench Attacks</a></h3></td><td style="text-align: left">An attacker uses <strong>physical violence, coercion, or threats</strong> (shifting toward <strong>psychological warfare</strong> and <strong>AI-enhanced</strong> tactics) to force a victim to surrender their private keys or assets, bypassing all technical security measures.</td><td style="text-align: left"><li><strong>Armed Robbery:</strong> Theft using lethal weapons.</li><li><strong>Blackmail:</strong> Threats to reveal compromising info.</li><li><strong>Extortion:</strong> Prolonged pressure or threats against loved ones.</li><li><strong>Home Invasion:</strong> Forceful entry, often by <strong>posing as utility/delivery workers</strong>.</li><li><strong>Kidnapping:</strong> Abduction, often via <strong>social engineering honey pots</strong> (fake meetings).</li><li><strong>Murder:</strong> Killing of a victim during theft.</li><li><strong>Physical Assault:</strong> Inflicting bodily harm to intimidate.</li><li><strong>Ransom:</strong> Demanding payment for victim release.</li><li><strong>Robbery:</strong> Theft using force/fear without lethal weapons.</li><li><strong>Torture:</strong> Inflicting severe pain to force disclosure.</li><br><strong>Threat Evolution:</strong><li><strong>Deepfake Extortion:</strong> Hyper-realistic proof of life (fake kidnapping).</li><li><strong>AI-Scaled Honey Pots:</strong> Autonomous agents managing thousands of fake relationships.</li></td><td style="text-align: left"><li><strong>Early Detection:</strong> Watch for unsolicited 2FA (digital compromise) or physical anomalies (unexpected visitors).</li><li><strong>Decoy Wallets:</strong> Maintain a plausible "duress" wallet.</li><li><strong>Segregation:</strong> Store seed phrases in bank vaults, separate from hardware wallets.</li><li><strong>OpSec:</strong> Remove crypto apps from daily phones; stop flexing; use dedicated hardware.</li><li><strong>Advanced Defense:</strong> Use <strong>Multi-Sig</strong> and <strong>Time-Locks</strong> to remove human single points of failure.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-125-vulnerable-vanityaddress-generators"><a class="header" href="#bwc-125-vulnerable-vanityaddress-generators">BWC 1.2.5: Vulnerable Vanity/Address Generators</a></h3></td><td style="text-align: left">Flaws in tools used to create <strong>custom, human-readable addresses</strong> (e.g., starting with <code>0xdead...</code>) that result in predictable or non-random private keys.</td><td style="text-align: left"><li>Using a generator with a <strong>weak source of randomness</strong>.</li><li>Exploiting bugs in the generation algorithm to <strong>brute-force the private key</strong>.</li></td><td style="text-align: left"><li>Only use <strong>well-audited, reputable</strong> vanity address generators.</li><li>Understand that vanity addresses may <strong>reduce privacy</strong> by linking an identity to an address.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-13-social-engineering--deception"><a class="header" href="#bwc-13-social-engineering--deception">BWC 1.3: Social Engineering &amp; Deception</a></h2></td><td style="text-align: left"><h3 id="bwc-131-social-engineering-exploits"><a class="header" href="#bwc-131-social-engineering-exploits">BWC 1.3.1: Social Engineering Exploits</a></h3></td><td style="text-align: left"><strong>Tricking users</strong> into revealing sensitive information or performing actions against their interest through deception. Many modern campaigns are executed via <strong>"Drainer-as-a-Service"</strong> platforms, where affiliates use sophisticated kits to target users.</td><td style="text-align: left"><li><strong>Trusted Notification Phishing:</strong> Abusing the notification systems of legitimate platforms (e.g., fake GitHub grants notifications, Google Docs comments) to send phishing links from an official source.</li><li><strong>Recruitment scams</strong> (e.g., fake job offers requiring a "test" transaction).</li><li><strong>Investment/Pig Butchering scams</strong>.</li><li><strong>Malvertising:</strong> Using compromised ad network accounts (e.g., Google Ads) to target users searching for crypto-related keywords.</li><li><strong>Spam Campaigns:</strong> Creating mass spam on trusted platforms like GitHub issues to lure victims with fake airdrops or grants.</li><li><strong>Address poisoning</strong> (sending dust to an address to pollute transaction history).</li></td><td style="text-align: left"><li><strong>Verify the source of all requests,</strong> even if the notification comes from a legitimate domain. Navigate directly to the official project's website or platform to confirm any offers or alerts.</li><li>Implement <strong>protocol-level safeguards</strong> (e.g., time-delayed withdrawals).</li><li><strong>User education</strong> on common scams and the function of transaction signing.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-132-sim-swap-attack"><a class="header" href="#bwc-132-sim-swap-attack">BWC 1.3.2: SIM Swap Attack</a></h3></td><td style="text-align: left">An attacker illegally obtains a <strong>new SIM card</strong> for a victim's phone number, allowing them to intercept 2FA codes sent via SMS.</td><td style="text-align: left"><li><strong>Bribing or tricking</strong> mobile carrier employees.</li><li>Using <strong>leaked personal information</strong> to impersonate the victim to their mobile provider.</li></td><td style="text-align: left"><li>Use <strong>non-SMS based 2FA</strong> (e.g., authenticator apps, hardware keys).</li><li>Set up a <strong>PIN or password</strong> with your mobile carrier for account changes.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-133-front-end-hijackspoofing"><a class="header" href="#bwc-133-front-end-hijackspoofing">BWC 1.3.3: Front-End Hijack/Spoofing</a></h3></td><td style="text-align: left"><strong>Modifying a DApp's web interface</strong> to trick users into approving malicious transactions or revealing secrets. Attackers often use advanced "cloaking" to hide malicious payloads from security researchers while presenting them to targeted victims.</td><td style="text-align: left"><li><strong>DNS hijacking</strong> to redirect users to a fake site.</li><li><strong>Abuse of Trusted Hosts:</strong> Hosting a clean landing page on a high-reputation domain (e.g., Google Sites) while loading malicious drainer scripts from other trusted sources (e.g., jsDelivr, Google Cloud Storage) to evade blocklists.</li><li><strong>Re-registering Expired Domains:</strong> Acquiring the expired domains of defunct but previously legitimate crypto projects to inherit their established trust.</li><li><strong>Browser Fingerprinting:</strong> Using scripts to filter traffic, showing the malicious site only to specific targets (e.g., by geolocation) while redirecting researchers or bots to a benign page or a fake CAPTCHA.</li><li><strong>Compromising the front-end hosting server</strong> to inject malicious code.</li></td><td style="text-align: left"><li>Users should <strong>verify domain names</strong> and look for SSL certificates, while remaining aware that even trusted domains can be abused to serve malicious content.</li><li>Use <strong>hardware wallets</strong> to verify transaction details on a trusted screen.</li><li>Protocols can use <strong>ENS and IPFS</strong> for decentralized, content-addressed front-ends that are more resistant to hijacking and spoofing.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-134-fake-wallet-applications"><a class="header" href="#bwc-134-fake-wallet-applications">BWC 1.3.4: Fake Wallet Applications</a></h3></td><td style="text-align: left"><strong>Malicious mobile or desktop apps</strong> that impersonate legitimate wallets to steal private keys or seed phrases.</td><td style="text-align: left"><li>Distributing <strong>fake apps</strong> via unofficial app stores or phishing links.</li></td><td style="text-align: left"><li>Only download wallet software from <strong>official, verified sources</strong>.</li><li><strong>Verify checksums</strong> of downloaded binaries.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-135-malicious-browser-extensions"><a class="header" href="#bwc-135-malicious-browser-extensions">BWC 1.3.5: Malicious Browser Extensions</a></h3></td><td style="text-align: left"><strong>Browser extensions</strong> that steal secrets or inject malicious scripts into DApp front-ends.</td><td style="text-align: left"><li>An extension requests <strong>excessive permissions</strong> to read all site data.</li></td><td style="text-align: left"><li>Regularly <strong>audit browser extensions</strong> and their permissions.</li><li>Use a <strong>separate, clean browser profile</strong> for crypto activities.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-136-malicious-rpc-provider"><a class="header" href="#bwc-136-malicious-rpc-provider">BWC 1.3.6: Malicious RPC Provider</a></h3></td><td style="text-align: left">A <strong>custom RPC endpoint</strong> that returns false data to trick a user or wallet into signing a malicious transaction.</td><td style="text-align: left"><li>An RPC provider can <strong>lie about on-chain data</strong>, such as token balances or contract code, to deceive a user.</li><li>They can <strong>route your transaction through a public mempool</strong> where it might be exposed to MEV.</li><li>They can <strong>MEV your transaction themselves</strong> as an adversarial RPC provider.</li><li>They can <strong>log your IP and transactions</strong> for surveillance.</li></td><td style="text-align: left"><li>Use <strong>well-known, reputable RPC providers</strong>.</li><li><strong>Verify critical transaction details</strong> on a trusted third-party explorer.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-137-flawed-off-chain-infrastructure"><a class="header" href="#bwc-137-flawed-off-chain-infrastructure">BWC 1.3.7: Flawed Off-Chain Infrastructure</a></h3></td><td style="text-align: left"><strong>Design flaws in critical off-chain components</strong> (e.g., keeper bots, oracle nodes) that are essential for protocol health, causing them to fail under stressful or unexpected conditions like high network congestion.</td><td style="text-align: left"><li><strong>Liquidation keeper bots fail</strong> to submit transactions during high network congestion because their gas price logic is not adaptive, allowing auctions to fail.</li> <li><strong>Oracle nodes fail</strong> to update prices in a timely manner, leading to the use of stale data.</li></td><td style="text-align: left"><li>Treat critical off-chain components with the <strong>same security rigor as smart contracts</strong>, including robust design and audits.</li> <li>Design bots with <strong>adaptive strategies</strong> for handling network congestion, such as dynamic gas price calculation.</li> <li>Promote a <strong>diverse and decentralized ecosystem</strong> for off-chain roles to avoid single points of failure.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-138-sybil-attacks"><a class="header" href="#bwc-138-sybil-attacks">BWC 1.3.8: Sybil Attacks</a></h3></td><td style="text-align: left">A single entity creates a large number of pseudonymous identities to gain a disproportionate advantage in a system. This undermines mechanisms that assume unique participants, such as airdrop distributions, governance voting, and reputation systems.</td><td style="text-align: left"><li><strong>Airdrop Farming:</strong> Creating thousands of wallets with minimal activity to unfairly claim rewards intended for a broad user base.</li><li><strong>Governance Takeover:</strong> Using a large number of Sybil-controlled wallets to amass enough voting power to pass or block proposals maliciously.</li></td><td style="text-align: left"><li>Implement <strong>Sybil resistance mechanisms</strong>, such as Proof-of-Humanity (e.g., Worldcoin, BrightID) or knowledge-based authentication.</li><li>Use <strong>on-chain heuristics</strong> to detect coordinated wallet activity (e.g., identical funding patterns, synchronized transactions).</li><li>Design governance and reward systems that favor <strong>long-term engagement and stake-weighting</strong> over simple address counts.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-14-infrastructure--supply-chain-integrity"><a class="header" href="#bwc-14-infrastructure--supply-chain-integrity">BWC 1.4: Infrastructure &amp; Supply Chain Integrity</a></h2></td><td style="text-align: left"><h3 id="bwc-141-compromised-validatornode"><a class="header" href="#bwc-141-compromised-validatornode">BWC 1.4.1: Compromised Validator/Node</a></h3></td><td style="text-align: left">A <strong>validator or node operator is compromised</strong>, leading to malicious activities like transaction censorship, reordering, or double-spending.</td><td style="text-align: left"><li><strong>Private key theft</strong> from a validator node.</li><li><strong>Malicious software</strong> running on node infrastructure.</li></td><td style="text-align: left"><li>For stakers: use <strong>robust, dedicated infrastructure</strong>.</li><li>For protocols: ensure a high degree of <strong>validator decentralization</strong> to minimize the impact of a single compromised node.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-142-dns-hijacking-attacks"><a class="header" href="#bwc-142-dns-hijacking-attacks">BWC 1.4.2: DNS Hijacking Attacks</a></h3></td><td style="text-align: left"><strong>Redirecting traffic</strong> from a legitimate DApp website to a fraudulent phishing site by compromising DNS servers.</td><td style="text-align: left"><li><strong>Compromising a domain registrar account</strong>.</li><li><strong>BGP hijacking</strong>.</li></td><td style="text-align: left"><li>Use <strong>DNSSEC</strong> to authenticate DNS responses.</li><li>Users should use <strong>DNS-over-HTTPS (DoH)</strong> and a trusted resolver.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-143-compromised-communication-platforms"><a class="header" href="#bwc-143-compromised-communication-platforms">BWC 1.4.3: Compromised Communication Platforms</a></h3></td><td style="text-align: left"><strong>Hijacking of official project accounts</strong> (Discord, X/Twitter, Telegram) to post phishing links or spread misinformation.</td><td style="text-align: left"><li>Theft of <strong>social media admin credentials</strong> via phishing or malware.</li></td><td style="text-align: left"><li>Secure all team accounts with <strong>hardware key-based 2FA</strong>.</li><li>Establish an <strong>emergency communication channel</strong> separate from social media.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-144-supply-chain-attacks"><a class="header" href="#bwc-144-supply-chain-attacks">BWC 1.4.4: Supply Chain Attacks</a></h3></td><td style="text-align: left"><strong>Compromises in the development pipeline</strong>, including malicious dependencies, backdoored developer tools (compilers, IDEs), or insecure deployment processes.</td><td style="text-align: left"><li>Injecting <strong>malicious code</strong> into a popular library (e.g., NPM package).</li><li><strong>Backdoors in developer tools</strong> like compilers, IDEs, or extensions.</li><li><strong>Compromising a developer's machine</strong> to inject code at build time.</li></td><td style="text-align: left"><li><strong>Pin dependencies</strong> to specific, audited versions.</li><li>Use <strong>trusted developer tools</strong> and vet third-party extensions.</li><li>Create a <strong>Software Bill Of Materials (SBOM)</strong>.</li><li>Conduct regular <strong>dependency scanning and audits</strong> of the development environment.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-145-client-consensus-bug"><a class="header" href="#bwc-145-client-consensus-bug">BWC 1.4.5: Client Consensus Bug</a></h3></td><td style="text-align: left">A <strong>bug in a client's implementation</strong> of a core protocol rule (e.g., state root computation, block validation) that causes it to fail to reach or maintain consensus with the rest of the network.</td><td style="text-align: left"><li>A client <strong>incorrectly computes a state root</strong>, causing it to be rejected by other clients (e.g., the 2025 Reth bug).</li><li>A client <strong>fails to properly validate a block</strong> according to network rules.</li></td><td style="text-align: left"><li>Run a <strong>diverse set of clients</strong> to prevent a single client's bug from halting the network.</li><li>Implement <strong>rigorous testing and fuzzing</strong> of client software.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-146-client-api-bug"><a class="header" href="#bwc-146-client-api-bug">BWC 1.4.6: Client API Bug</a></h3></td><td style="text-align: left">A <strong>bug in a client's RPC/API layer</strong> that returns incorrect or misleading data to users or applications, potentially leading to flawed transactions or an incorrect view of on-chain state.</td><td style="text-align: left"><li>An RPC call returns a <strong>stale or incorrect balance</strong> for an account.</li><li>An API endpoint for transaction simulation provides a result that <strong>differs from actual execution</strong>.</li></td><td style="text-align: left"><li><strong>Cross-reference data</strong> with multiple independent sources (e.g., different block explorers or nodes).</li><li>DApps should have <strong>robust error handling</strong> for unexpected API responses.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-147-communication-link-hijacking"><a class="header" href="#bwc-147-communication-link-hijacking">BWC 1.4.7: Communication Link Hijacking</a></h3></td><td style="text-align: left">Failure to maintain ownership of critical communication links (e.g., social media vanity URLs), allowing scammers to claim the expired links and impersonate the project. This turns all historical references to that link into phishing traps.</td><td style="text-align: left"><li>Allowing a custom Discord or Telegram vanity URL to <strong>expire</strong>, which is then registered by a scammer.</li><li>Attackers weaponizing <strong>outdated links</strong> in project documentation, social media profiles (CoinGecko, CMC), and historical tweets to direct users to phishing sites.</li></td><td style="text-align: left"><li>Continuously <strong>monitor and renew</strong> all custom vanity URLs and branded links.</li><li>Regularly <strong>audit and update</strong> all public-facing profiles and documentation to ensure links are current and active.</li><li>Establish a clear process for <strong>deprecating and removing old links</strong> from all platforms.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-15-nation-state--advanced-persistent-threats-apts"><a class="header" href="#bwc-15-nation-state--advanced-persistent-threats-apts">BWC 1.5: Nation-State &amp; Advanced Persistent Threats (APTs)</a></h2></td><td style="text-align: left"><h3 id="bwc-151-coordinated-multi-vector-attacks"><a class="header" href="#bwc-151-coordinated-multi-vector-attacks">BWC 1.5.1: Coordinated Multi-Vector Attacks</a></h3></td><td style="text-align: left"><strong>Sophisticated, large-scale attacks</strong>, often attributed to nation-states or organized crime (e.g., Lazarus Group), that combine multiple tactics simultaneously.</td><td style="text-align: left"><li>Combining <strong>social engineering</strong> (fake job offers), <strong>malware</strong> (laced PDFs), and <strong>smart contract exploits</strong> in a single, coordinated campaign.</li></td><td style="text-align: left"><li>Extreme <strong>operational security (OPSEC)</strong> for team members.</li><li><strong>Compartmentalize roles and permissions</strong>.</li><li><strong>Constant vigilance</strong> and employee training.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-152-state-sponsored-infrastructure-compromise"><a class="header" href="#bwc-152-state-sponsored-infrastructure-compromise">BWC 1.5.2: State-Sponsored Infrastructure Compromise</a></h3></td><td style="text-align: left"><strong>Nation-state actors targeting core internet infrastructure</strong> (e.g., DNS, BGP, certificate authorities) to intercept or redirect traffic for entire ecosystems.</td><td style="text-align: left"><li><strong>BGP hijacking</strong> to reroute traffic to state-controlled servers.</li><li><strong>Compromising a certificate authority</strong> to issue fraudulent TLS certificates.</li></td><td style="text-align: left"><li>Use of <strong>decentralized infrastructure</strong> (e.g., ENS, IPFS).</li><li><strong>DNSSEC</strong> and other cryptographic verification methods.</li><li><strong>User-side vigilance</strong> (e.g., using trusted VPNs).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-153-geopolitical-economic-warfare"><a class="header" href="#bwc-153-geopolitical-economic-warfare">BWC 1.5.3: Geopolitical Economic Warfare</a></h3></td><td style="text-align: left">Using blockchain and DeFi protocols as <strong>instruments of economic warfare</strong>, such as evading sanctions or destabilizing the financial systems of rival states.</td><td style="text-align: left"><li>State-sponsored entities using <strong>mixers and privacy coins</strong> to launder stolen funds.</li><li><strong>Targeting a country's financial infrastructure</strong> by attacking its digital currency systems.</li></td><td style="text-align: left"><li><strong>Regulatory compliance</strong> (where applicable).</li><li><strong>On-chain monitoring and heuristics</strong> to detect sanctioned activity.</li><li><strong>International cooperation</strong> between law enforcement agencies.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-154-cross-jurisdictional-regulatory-exploitation"><a class="header" href="#bwc-154-cross-jurisdictional-regulatory-exploitation">BWC 1.5.4: Cross-Jurisdictional Regulatory Exploitation</a></h3></td><td style="text-align: left"><strong>Exploiting inconsistencies and loopholes in regulations</strong> across different legal jurisdictions to conduct malicious activities that are difficult to prosecute.</td><td style="text-align: left"><li>Hosting different parts of a malicious operation in countries with <strong>lax regulations</strong>.</li><li>Using <strong>shell corporations</strong> in multiple jurisdictions to obscure ownership.</li></td><td style="text-align: left"><li><strong>Harmonization of international regulations</strong>.</li><li>Enhanced <strong>due diligence and Know Your Customer (KYC)</strong> processes.</li><li><strong>Chain analysis</strong> to trace fund flows across jurisdictions.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-155-geopolitically-induced-network-stress"><a class="header" href="#bwc-155-geopolitically-induced-network-stress">BWC 1.5.5: Geopolitically-Induced Network Stress</a></h3></td><td style="text-align: left">The intentional or unintentional creation of <strong>extreme market volatility and network congestion</strong> stemming from major geopolitical events. This stress can cause cascading failures in critical on-chain and off-chain infrastructure, leading to mass liquidations, oracle failures, and protocol insolvency.</td><td style="text-align: left"><li><strong>Tariff Wars &amp; Sanctions:</strong> Sudden, severe economic actions causing market panic and a flight to safety, triggering massive sell-offs and extreme network congestion.</li><li><strong>Physical or Cyber Attacks:</strong> Major real-world events (e.g., terror attacks, critical infrastructure sabotage) that create global market instability, directly impacting crypto asset prices and network usability.</li><li><strong>Targeted Economic Destabilization:</strong> A nation-state intentionally creating market chaos to exploit protocol weaknesses that only emerge under extreme stress, such as oracle failures or liquidation system collapse.</li></td><td style="text-align: left"><li><strong>Robust Systemic Design:</strong> Protocols must design their economic and liquidation mechanisms to withstand "black swan" events and extreme, sustained market volatility.</li><li><strong>Diversified and Resilient Oracles:</strong> Oracles should not rely on a single source of truth and must have mechanisms to remain reliable during periods of intense network congestion.</li><li><strong>Decentralized and Adaptive Keepers:</strong> Liquidation and auction systems should not rely on a centralized or homogenous set of keepers. The system should incentivize a diverse set of participants who can operate under high-cost network conditions.</li><li><strong>Circuit Breakers:</strong> Implement automated "circuit breakers" that can pause critical protocol functions during periods of unprecedented volatility to prevent catastrophic failure and allow for manual intervention.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-2-access-control-vulnerabilities"><a class="header" href="#bwc-2-access-control-vulnerabilities">BWC 2: Access Control Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-21-missing-or-improper-authorization"><a class="header" href="#bwc-21-missing-or-improper-authorization">BWC 2.1: Missing or Improper Authorization</a></h2></td><td style="text-align: left"><h3 id="bwc-211-missing-access-control"><a class="header" href="#bwc-211-missing-access-control">BWC 2.1.1: Missing Access Control</a></h3></td><td style="text-align: left"><strong>Failure to implement any or sufficient authorization checks</strong>, allowing sensitive functions to be called by any user.</td><td style="text-align: left"><li>Calling a function like <code>initialize()</code> or <code>setOwner()</code> that was intended to be called only once but was left <strong><code>public</code></strong>.</li></td><td style="text-align: left"><li>Use function modifiers (e.g., <strong><code>onlyOwner</code></strong>).</li><li>Set correct visibility (e.g., <strong><code>internal</code></strong>, <strong><code>private</code></strong>).</li><li>Follow the principle of <strong>least privilege</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-212-txorigin-authorization"><a class="header" href="#bwc-212-txorigin-authorization">BWC 2.1.2: tx.origin Authorization</a></h3></td><td style="text-align: left">Using <strong><code>tx.origin</code> for authorization</strong>, which is insecure as it makes the contract vulnerable to phishing attacks where a user is tricked into calling a malicious intermediary contract.</td><td style="text-align: left"><li>A victim calls a malicious contract <code>A</code>, which then calls the vulnerable contract <code>B</code>. Inside <code>B</code>, a check for <strong><code>tx.origin == victim_address</code></strong> passes, granting <code>A</code> the victim's privileges.</li></td><td style="text-align: left"><li>Always use <strong><code>msg.sender</code> for authorization</strong>, as it identifies the immediate caller.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-22-flawed-permission-management"><a class="header" href="#bwc-22-flawed-permission-management">BWC 2.2: Flawed Permission Management</a></h2></td><td style="text-align: left"><h3 id="bwc-221-unsafe-token-approvals"><a class="header" href="#bwc-221-unsafe-token-approvals">BWC 2.2.1: Unsafe Token Approvals</a></h3></td><td style="text-align: left">Granting <strong>excessive or indefinite token allowances</strong> (<code>ERC20.approve</code>) to smart contracts, which can lead to fund theft if the approved contract is compromised or malicious.</td><td style="text-align: left"><li>A user approves a contract for an <strong>unlimited amount of tokens</strong>. The contract is later exploited, and the attacker calls <code>transferFrom</code> to drain the user's wallet.</li><li>Granting token approvals to <strong>permissionless "helper" or "executor" contracts</strong> (e.g., multicall or settler contracts). Since anyone can call these contracts, an attacker can instruct the contract to transfer the approved tokens to themselves.</li></td><td style="text-align: left"><li>Approve only the <strong>exact amount needed</strong> for a transaction.</li><li>Use standards like <strong>EIP-2612 (<code>permit</code>)</strong> for gasless, single-transaction approvals.</li><li>Regularly <strong>revoke old allowances</strong> using tools like Revoke.cash.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-222-misconfigured-proxy"><a class="header" href="#bwc-222-misconfigured-proxy">BWC 2.2.2: Misconfigured Proxy</a></h3></td><td style="text-align: left"><strong>Errors in deploying or managing proxy patterns</strong> (like Transparent or UUPS proxies) that can lead to storage collisions, lost implementations, or unauthorized upgrades.</td><td style="text-align: left"><li>Forgetting to <strong>initialize the implementation contract</strong>, allowing an attacker to claim ownership.</li><li><strong>Storage layout</strong> of the proxy and implementation are not compatible, leading to data corruption.</li><li><strong>Constructor State Initialization:</strong> Using a constructor in the implementation contract to set storage variables. Since the constructor runs in the context of the implementation address, the proxy's storage remains uninitialized.</li></td><td style="text-align: left"><li>Use <strong>well-audited, standard proxy implementations</strong> (e.g., from OpenZeppelin).</li><li>Follow documented procedures for <strong>deployment and upgrades</strong> carefully.</li><li>Use tools to check for <strong>storage layout compatibility</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-223-untrusted-arbitrary-calls"><a class="header" href="#bwc-223-untrusted-arbitrary-calls">BWC 2.2.3: Untrusted Arbitrary Calls</a></h3></td><td style="text-align: left">The contract allows an attacker to specify the <strong>target and calldata for a low-level call</strong> (e.g., <code>.call()</code>). This allows the attacker to force the contract to execute any action in its own context, effectively impersonating it.</td><td style="text-align: left"><li><strong>Stealing User Funds (via Approvals):</strong> The attacker forces the contract to call <code>token.transferFrom(victim, attacker, amount)</code>. Since the victim has approved the contract (BWC 2.2.1), the token contract accepts the request.</li><li><strong>Stealing Contract Funds:</strong> The attacker forces the contract to call <code>token.transfer(attacker, amount)</code> to drain assets held by the contract itself.</li></td><td style="text-align: left"><li>Avoid allowing arbitrary calls to user-supplied addresses.</li><li>Use a <strong>whitelist of trusted contracts</strong>.</li><li>If arbitrary calls are required, <strong>blacklist sensitive selectors</strong> like <code>transferFrom</code> or <code>approve</code>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-224-composable-arbitrary-calls"><a class="header" href="#bwc-224-composable-arbitrary-calls">BWC 2.2.4: Composable Arbitrary Calls</a></h3></td><td style="text-align: left">An exploit where <strong>composing multiple, individually secure contracts</strong> allows an attacker to make a contract perform a malicious, arbitrary call that would not be possible in isolation.</td><td style="text-align: left"><li>A DeFi protocol allows users to execute a sequence of operations. An attacker crafts a sequence that causes an intermediate contract to call a third, unrelated protocol in an <strong>unexpected way</strong>.</li></td><td style="text-align: left"><li>Carefully audit and reason about all possible <strong>interactions with external protocols</strong>.</li><li>Implement checks to prevent <strong>unexpected external calls</strong> within a multi-step operation.</li><li>Use <strong>reentrancy guards</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-225-ruggable-contract-design"><a class="header" href="#bwc-225-ruggable-contract-design">BWC 2.2.5: Ruggable Contract Design</a></h3></td><td style="text-align: left"><strong>Architectural design that intentionally allows privileged developers</strong> to steal or freeze user funds without warning.</td><td style="text-align: left"><li>A contract owner has a function to <strong>withdraw all user deposits</strong>.</li><li>A proxy implementation can be <strong>changed to a malicious contract</strong> at any time.</li></td><td style="text-align: left"><li>Use <strong>timelocks</strong> for all privileged operations.</li><li><strong>Decentralize or burn ownership</strong> where possible.</li><li>Ensure proxy upgrade paths are controlled by a <strong>DAO or secure multi-sig</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-23-callback--hook-vulnerabilities"><a class="header" href="#bwc-23-callback--hook-vulnerabilities">BWC 2.3: Callback &amp; Hook Vulnerabilities</a></h2></td><td style="text-align: left"><h3 id="bwc-231-missing-validation-in-callbacks"><a class="header" href="#bwc-231-missing-validation-in-callbacks">BWC 2.3.1: Missing Validation in Callbacks</a></h3></td><td style="text-align: left"><strong>Failure to verify the caller or parameters</strong> of a public callback function. These functions (e.g., flashloan receivers, token hooks like <code>onERC1155Received</code>) must act as gatekeepers, but if they fail to authenticate that the caller is the specific trusted contract (e.g., the lending pool or the token contract), an attacker can invoke them directly to spoof events.</td><td style="text-align: left"><li><strong>Spoofing Deposits:</strong> Calling <code>onERC1155Received</code> or <code>onERC721Received</code> directly to simulate a deposit and trigger internal accounting logic (e.g., minting wrapper tokens) without actually transferring assets (e.g., the TSURU exploit).</li><li><strong>Malicious Flashloan Data:</strong> An attacker invokes a flashloan callback directly, passing malicious data to bypass checks or manipulate state intended only for the legitimate lending pool execution context.</li></td><td style="text-align: left"><li><strong>Authenticate <code>msg.sender</code>:</strong> Strictly verify that the caller is the expected token contract or lending pool address.</li><li><strong>Verify State Changes:</strong> Ensure that the assets associated with the callback (e.g., loan principal, deposited tokens) have actually been received or transferred.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-3-smart-contract-logic--state-manipulation"><a class="header" href="#bwc-3-smart-contract-logic--state-manipulation">BWC 3: Smart Contract Logic &amp; State Manipulation</a></h1></td><td style="text-align: left"><h2 id="bwc-31-reentrancy-attacks"><a class="header" href="#bwc-31-reentrancy-attacks">BWC 3.1: Reentrancy Attacks</a></h2></td><td style="text-align: left"><h3 id="bwc-311-standard-reentrancy"><a class="header" href="#bwc-311-standard-reentrancy">BWC 3.1.1: Standard Reentrancy</a></h3></td><td style="text-align: left">An attacker's contract <strong>calls back into a vulnerable contract</strong> before its state updates are completed, allowing for multiple withdrawals or other exploits.</td><td style="text-align: left"><li>A contract withdraws Ether, then <strong>re-enters the withdrawal function</strong> before its balance is updated, draining the contract.</li></td><td style="text-align: left"><li>Use the <strong>Checks-Effects-Interactions</strong> pattern.</li><li>Use <strong>reentrancy guard modifiers</strong> (e.g., OpenZeppelin's <code>nonReentrant</code>).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-312-erc-777-reentrancy"><a class="header" href="#bwc-312-erc-777-reentrancy">BWC 3.1.2: ERC-777 Reentrancy</a></h3></td><td style="text-align: left"><strong>Exploiting token hooks</strong> in the ERC-777 standard (<code>tokensToSend</code> or <code>tokensReceived</code>) to reenter contracts during a token transfer.</td><td style="text-align: left"><li>An attacker crafts a malicious contract as the recipient of an ERC-777 token. The <strong><code>tokensReceived</code> hook</strong> on the malicious contract calls back into the victim contract.</li></td><td style="text-align: left"><li>Use <strong>reentrancy guards</strong>.</li><li>Be aware of the reentrancy possibilities when using <strong>ERC-777 tokens</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-313-read-only-reentrancy"><a class="header" href="#bwc-313-read-only-reentrancy">BWC 3.1.3: Read-only Reentrancy</a></h3></td><td style="text-align: left"><strong>Reentering a contract to read a state</strong> that is inconsistent or in the process of being changed, leading to logic errors, even if no state is written in the second call.</td><td style="text-align: left"><li>An attacker calls a function that changes state, and in the same transaction, <strong>re-enters to read that state</strong> before the change is finalized, leading to incorrect calculations.</li></td><td style="text-align: left"><li>Use <strong>view/read-only reentrancy guards</strong>.</li><li>Ensure all state is <strong>updated before any external calls</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-314-composable-reentrancy"><a class="header" href="#bwc-314-composable-reentrancy">BWC 3.1.4: Composable Reentrancy</a></h3></td><td style="text-align: left">A reentrancy attack that becomes possible due to <strong>unforeseen interactions between multiple, otherwise secure, contracts</strong>. The vulnerability emerges from the composition of protocols.</td><td style="text-align: left"><li>Protocol A calls Protocol B. An attacker finds a way to make Protocol B <strong>call back into Protocol A</strong>, bypassing its reentrancy guard because the direct caller is Protocol B.</li></td><td style="text-align: left"><li>Use <strong>context-aware reentrancy guards</strong> if possible.</li><li>Thoroughly <strong>audit all integrations</strong> with external protocols.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-32-flawed-state-management"><a class="header" href="#bwc-32-flawed-state-management">BWC 3.2: Flawed State Management</a></h2></td><td style="text-align: left"><h3 id="bwc-321-improper-initialization"><a class="header" href="#bwc-321-improper-initialization">BWC 3.2.1: Improper Initialization</a></h3></td><td style="text-align: left">Contracts deployed with <strong>incorrect initial state, missing initialization, or unset flags</strong>, often leaving them ownerless or in a vulnerable state.</td><td style="text-align: left"><li>Deploying a proxy contract but <strong>failing to call the <code>initialize</code> function</strong> on the implementation, allowing an attacker to claim ownership.</li></td><td style="text-align: left"><li>Use <strong>constructor initialization</strong> where possible.</li><li>Ensure initializer functions can only be <strong>called once</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-322-faulty-contract-checks"><a class="header" href="#bwc-322-faulty-contract-checks">BWC 3.2.2: Faulty Contract Checks</a></h3></td><td style="text-align: left"><strong>Logic errors in mechanisms that check the status or code of other contracts</strong>, such as verifying if an address is a contract or not.</td><td style="text-align: left"><li>Using <strong><code>extcodesize</code> to check for an EOA</strong>, which can be bypassed if the check is performed during contract construction.</li></td><td style="text-align: left"><li>A more reliable check for contract existence is <strong><code>address.code.length &gt; 0</code></strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-323-forced-ether-balance"><a class="header" href="#bwc-323-forced-ether-balance">BWC 3.2.3: Forced Ether Balance</a></h3></td><td style="text-align: left"><strong>Manipulating a contract's Ether balance</strong> to disrupt logic that depends on <code>address(this).balance</code>.</td><td style="text-align: left"><li>An attacker can forcibly send Ether to any contract via <strong><code>selfdestruct(victim_address)</code></strong>.</li></td><td style="text-align: left"><li><strong>Avoid using <code>address(this).balance</code></strong> for critical logic. Design contracts to be agnostic to their Ether balance.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-324-self-transfers-and-transaction-timing-attacks"><a class="header" href="#bwc-324-self-transfers-and-transaction-timing-attacks">BWC 3.2.4: Self Transfers and Transaction Timing Attacks</a></h3></td><td style="text-align: left"><strong>Exploiting state changes</strong> caused by transfers to the same address or by the ordering of transactions within a block.</td><td style="text-align: left"><li>In a token contract, <strong>transferring tokens to oneself</strong> might bypass certain checks or trigger reward logic incorrectly.</li></td><td style="text-align: left"><li>Add checks to prevent transfers where the <strong>sender and recipient are the same</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-325-broken-state-adjustment"><a class="header" href="#bwc-325-broken-state-adjustment">BWC 3.2.5: Broken State Adjustment</a></h3></td><td style="text-align: left"><strong>Errors in logic</strong> that are supposed to modify or correct contract state, leading to inconsistent or exploitable conditions.</td><td style="text-align: left"><li>A function that is supposed to burn tokens <strong>fails to update the total supply</strong> correctly.</li></td><td style="text-align: left"><li><strong>Rigorous unit testing</strong> of all state-changing functions.</li><li>Use <strong>formal verification</strong> to prove state consistency.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-326-proxycontract-initialization-front-running"><a class="header" href="#bwc-326-proxycontract-initialization-front-running">BWC 3.2.6: Proxy/Contract Initialization Front-Running</a></h3></td><td style="text-align: left">An attacker observes a transaction that deploys a contract and immediately sends a transaction with a higher gas fee to <strong>initialize the contract with their own address as the owner</strong>.</td><td style="text-align: left"><li>An attacker sees a new proxy contract deployment in the mempool and <strong>rushes to call its <code>initialize</code> function</strong> before the legitimate deployer does.</li></td><td style="text-align: left"><li><strong>Combine deployment and initialization</strong> into a single transaction using a factory contract.</li><li>Ensure initializer functions have proper <strong>access control</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-327-broken-invariant-via-function-overriding"><a class="header" href="#bwc-327-broken-invariant-via-function-overriding">BWC 3.2.7: Broken Invariant via Function Overriding</a></h3></td><td style="text-align: left">A vulnerability created when a child contract inherits from a parent (e.g., an OpenZeppelin standard) and overrides an internal function. By altering the logic or removing critical checks in the overridden function, the child contract breaks the security assumptions (invariants) of other, non-overridden public functions in the parent contract that rely on the original internal function's behavior.</td><td style="text-align: left"><li>An attacker identifies a public function (e.g., <code>mint</code>) in a parent contract that relies on an internal function (e.g., <code>_deposit</code>) for a critical check.</li><li>The child contract has overridden the internal function but failed to replicate the critical check, often moving it to a different public function (e.g., <code>deposit</code>).</li><li>The attacker calls the original, non-overridden public function, which then executes the new, insecure internal logic, bypassing the critical check and leading to exploits like free mints or unauthorized withdrawals.</li></td><td style="text-align: left"><li><strong>Thoroughly Review Parent Contracts:</strong> When inheriting, developers must understand all internal dependencies of the parent contract. All public functions that rely on an internal function must be considered before that internal function is overridden.</li><li><strong>Preserve Invariants:</strong> If overriding an internal function, ensure that all of its original security guarantees (invariants), such as asset receipt checks or access controls, are either preserved in the new implementation or explicitly replicated in every public function that depends on it.</li><li><strong>Favor Composition over Inheritance:</strong> Where possible, use composition (i.e., using external libraries or contracts) instead of inheritance to avoid complex and fragile dependency chains.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-328-faulty-array--list-handling"><a class="header" href="#bwc-328-faulty-array--list-handling">BWC 3.2.8: Faulty Array &amp; List Handling</a></h3></td><td style="text-align: left"><strong>Logic errors arising from the improper manipulation, validation, or searching of array data structures.</strong> This includes failing to sanitize inputs for duplicate entries or using search algorithms (like binary search) on arrays that violate uniqueness assumptions (e.g., duplicate timestamps), leading to incorrect accounting or stale data retrieval.</td><td style="text-align: left"><li><strong>Duplicate Asset/Reward Exploits:</strong> An attacker creates an offer or interaction supplying an array of tokens that contains duplicates. If the protocol iterates through the array to issue rewards without deduplicating, the attacker drains the system by claiming the reward multiple times for a single action (e.g., the Royco exploit).</li><li><strong>Binary Search Failure via Duplicates:</strong> In systems that track historical data (checkpoints), an attacker triggers multiple updates in a single block to create entries with duplicate timestamps. If the binary search implementation assumes unique keys, it may return the first (stale) entry instead of the latest one, leading to incorrect calculations (e.g., the Alchemix exploit).</li></td><td style="text-align: left"><li><strong>Input Sanitization:</strong> Explicitly validate array inputs to ensure there are no duplicate entries, or use a <code>mapping</code> to track processed items during iteration.</li><li><strong>Enforce Uniqueness:</strong> Ensure data structures used for historical lookups enforce strict uniqueness of keys (e.g., overwrite existing checkpoints if the timestamp is the same).</li><li><strong>Robust Search Logic:</strong> When using binary search on potential duplicates, ensure the algorithm is designed to find the specific bound (e.g., the last occurrence) required by the protocol's logic.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-33-token-standard--logic-issues"><a class="header" href="#bwc-33-token-standard--logic-issues">BWC 3.3: Token Standard &amp; Logic Issues</a></h2></td><td style="text-align: left"><h3 id="bwc-331-double-entrypoint-tokens"><a class="header" href="#bwc-331-double-entrypoint-tokens">BWC 3.3.1: Double EntryPoint Tokens</a></h3></td><td style="text-align: left">Contracts where a native token also has an <strong>ERC-20 representation</strong>, potentially leading to inconsistent state or accounting if not handled carefully.</td><td style="text-align: left"><li>A bridge or protocol only accounts for the ERC-20 version, while value is moved via the native transfer mechanism, leading to a <strong>desync</strong>.</li></td><td style="text-align: left"><li>Ensure the contract logic correctly handles both the <strong>native and ERC-20 representations</strong> and keeps their states synchronized.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-332-fee-on-transfer--rebase-accounting-issues"><a class="header" href="#bwc-332-fee-on-transfer--rebase-accounting-issues">BWC 3.3.2: Fee-on-Transfer &amp; Rebase Accounting Issues</a></h3></td><td style="text-align: left"><strong>Incorrect handling of tokens</strong> that deduct fees during transfers or have an elastic supply (rebase tokens), leading to incorrect balance calculations.</td><td style="text-align: left"><li>A protocol assumes that if it transfers <code>X</code> tokens, the recipient will receive <code>X</code> tokens, which is not true for <strong>fee-on-transfer tokens</strong>.</li></td><td style="text-align: left"><li><strong>Cache token balances</strong> before and after a transfer to determine the actual amount received.</li><li>Avoid using tokens with <strong>non-standard mechanics</strong> if possible.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-333-improper-handling-of-native-tokens"><a class="header" href="#bwc-333-improper-handling-of-native-tokens">BWC 3.3.3: Improper Handling of Native Tokens</a></h3></td><td style="text-align: left"><strong>Errors in managing the blockchain's native currency</strong> (e.g., ETH, BNB) alongside other tokens, often related to payable functions or <code>msg.value</code>.</td><td style="text-align: left"><li>A function incorrectly uses <strong><code>msg.value</code></strong> or fails to check it, leading to over or underpayment.</li></td><td style="text-align: left"><li>Always <strong>validate <code>msg.value</code></strong> in payable functions.</li><li>Use the <strong>Checks-Effects-Interactions pattern</strong> when sending Ether.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-334-weird-erc20-behaviors"><a class="header" href="#bwc-334-weird-erc20-behaviors">BWC 3.3.4: Weird ERC20 Behaviors</a></h3></td><td style="text-align: left">Failure to handle <strong>non-standard implementations of the ERC20 interface</strong>, such as tokens that do not return a boolean on success for <code>transfer</code> or <code>approve</code>.</td><td style="text-align: left"><li>A contract calls <code>transfer</code> on a non-compliant token, and the call succeeds but does not return <code>true</code>, causing the calling contract to <strong>revert</strong>.</li></td><td style="text-align: left"><li>Use OpenZeppelin's <strong><code>SafeERC20</code> library</strong>, which handles these edge cases.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-335-eip-standard-non-compliance"><a class="header" href="#bwc-335-eip-standard-non-compliance">BWC 3.3.5: EIP Standard Non-Compliance</a></h3></td><td style="text-align: left">A contract implements a feature based on a non-token EIP standard (e.g., ERC-3156 for flash loans, ERC-721 for NFTs) but <strong>deviates from the standard's required logic.</strong> This leads to <strong>broken interoperability</strong> with other compliant contracts and creates unexpected behaviors or logical flaws.</td><td style="text-align: left"><li>A compliant external contract attempts to interact with the non-compliant function, leading to reverted transactions or incorrect state changes because the expected interface and behavior do not match.</li><li>The non-compliant implementation may lack critical safety checks or return values specified in the EIP, which other protocols rely on for safe integration.</li></td><td style="text-align: left"><li><strong>Adhere Strictly to Standards:</strong> When implementing a feature based on a public EIP, follow the specification precisely, including function signatures, return values, and required checks (e.g., pulling funds back after a flash loan).</li><li><strong>Use Standard Libraries:</strong> Rely on well-audited, community-vetted implementations of common EIPs (e.g., from OpenZeppelin) to ensure compliance and avoid introducing subtle deviations.</li><li><strong>Test for Composability:</strong> Actively test integrations with other known, compliant contracts to ensure the implementation behaves as expected within the broader ecosystem.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-34-governance--system-logic"><a class="header" href="#bwc-34-governance--system-logic"> BWC 3.4: Governance &amp; System Logic</a></h2></td><td style="text-align: left"><h3 id="bwc-341-dao-governance-attacks"><a class="header" href="#bwc-341-dao-governance-attacks">BWC 3.4.1: DAO Governance Attacks</a></h3></td><td style="text-align: left"><strong>Exploiting voting mechanisms, proposal processes, or timelocks</strong> to pass malicious proposals or seize control of a protocol.</td><td style="text-align: left"><li>Using <strong>flash-loaned tokens</strong> to gain enough voting power to pass a malicious proposal.</li></td><td style="text-align: left"><li>Require a <strong>minimum token holding period</strong> before votes are counted.</li><li>Implement a reasonable <strong>timelock duration</strong> for proposal execution.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-342-flawed-incentive-structures"><a class="header" href="#bwc-342-flawed-incentive-structures">BWC 3.4.2: Flawed Incentive Structures</a></h3></td><td style="text-align: left"><strong>Exploitable incentive structures or reward calculation errors</strong> that allow attackers to claim unfair rewards. This includes design flaws in penalty or slashing mechanisms where the funds are "donated" in a way that allows the penalized attacker to also be the beneficiary, effectively negating the penalty.</td><td style="text-align: left"><li>An attacker finds a way to <strong>repeatedly claim staking rewards</strong> without locking up any real assets.</li><li><strong>Self-Serving Penalty:</strong> An attacker uses a secondary account to become the sole recipient in a penalty distribution zone. They then perform the penalized action with their primary account, and the penalty is "paid" directly to their secondary account, resulting in no net loss.</li></td><td style="text-align: left"><li>Thoroughly <strong>model and test all reward and penalty logic</strong>.</li><li>Implement <strong>caps on rewards</strong> or use a time-weighted system.</li><li>Ensure penalty funds are sent to a <strong>neutral, non-manipulable destination</strong> (e.g., a treasury or burn address).</li><li>Design penalty mechanisms to prevent reflexive scenarios where the <strong>payer and payee can be the same entity</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-343-bridge-status-mismatch"><a class="header" href="#bwc-343-bridge-status-mismatch">BWC 3.4.3: Bridge Status Mismatch</a></h3></td><td style="text-align: left"><strong>Inconsistencies between cross-chain bridge endpoints</strong> leading to fund loss or transaction failure, often due to one side of the bridge being paused or upgraded while the other is not.</td><td style="text-align: left"><li>A user sends funds to a bridge on Chain A, but the contract on Chain B is <strong>paused</strong>, trapping the funds.</li></td><td style="text-align: left"><li>Implement a <strong>cross-chain mechanism to pause</strong> the entire bridge simultaneously.</li><li>Provide <strong>clear status indicators</strong> on the bridge interface.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-4-input--data-validation-vulnerabilities"><a class="header" href="#bwc-4-input--data-validation-vulnerabilities">BWC 4: Input &amp; Data Validation Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-41-insufficient-input-validation"><a class="header" href="#bwc-41-insufficient-input-validation">BWC 4.1: Insufficient Input Validation</a></h2></td><td style="text-align: left"><h3 id="bwc-411-insufficient-input-validation"><a class="header" href="#bwc-411-insufficient-input-validation">BWC 4.1.1: Insufficient Input Validation</a></h3></td><td style="text-align: left"><strong>Failure to properly sanitize or validate transaction inputs</strong>, enabling malicious or unexpected data to be processed. This includes missing zero-address checks.</td><td style="text-align: left"><li>A user can pass a <strong>zero address</strong> for a critical parameter, leading to burned funds or locked contracts.</li><li>Passing a <strong>malicious contract address</strong> where an EOA is expected.</li></td><td style="text-align: left"><li><strong>Validate all inputs for correctness</strong> (e.g., check for zero addresses, ensure values are within expected ranges).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-42-oracle-manipulation--data-integrity"><a class="header" href="#bwc-42-oracle-manipulation--data-integrity">BWC 4.2: Oracle Manipulation &amp; Data Integrity</a></h2></td><td style="text-align: left"><h3 id="bwc-421-insufficient-oracle-validation"><a class="header" href="#bwc-421-insufficient-oracle-validation">BWC 4.2.1: Insufficient Oracle Validation</a></h3></td><td style="text-align: left"><strong>Inadequate verification of external data feeds</strong> (e.g., price feeds), allowing manipulation of critical on-chain information.</td><td style="text-align: left"><li>A protocol uses a price oracle but <strong>fails to check if the returned price is recent</strong> or if the oracle round is complete, leading to the use of stale data.</li></td><td style="text-align: left"><li>Use reputable oracle providers like <strong>Chainlink</strong>.</li><li><strong>Check oracle heartbeat and timestamp</strong> to ensure data freshness.</li><li>Implement <strong>circuit breakers</strong> to halt operations if prices move too drastically.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-422-oracle-manipulation"><a class="header" href="#bwc-422-oracle-manipulation">BWC 4.2.2: Oracle Manipulation</a></h3></td><td style="text-align: left"><strong>Actively compromising or gaming the data feeds</strong> that DApps rely on for external information, often by manipulating the price on a low-liquidity decentralized exchange that an oracle uses as its source.</td><td style="text-align: left"><li>Using a <strong>flash loan to execute a large trade</strong> on a DEX, momentarily skewing the price, and then using that manipulated price in another protocol to take out an unfair loan.</li></td><td style="text-align: left"><li>Use oracles that <strong>aggregate prices</strong> from multiple, high-liquidity sources.</li><li>Use <strong>Time-Weighted Average Price (TWAP) oracles</strong>, which are more resistant to manipulation.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-43-cryptographic-signature-flaws"><a class="header" href="#bwc-43-cryptographic-signature-flaws">BWC 4.3: Cryptographic Signature Flaws</a></h2></td><td style="text-align: left"><h3 id="bwc-431-missing-signature-validation"><a class="header" href="#bwc-431-missing-signature-validation">BWC 4.3.1: Missing Signature Validation</a></h3></td><td style="text-align: left"><strong>Improper or missing verification of cryptographic signatures</strong>, enabling transaction forgery or replay attacks.</td><td style="text-align: left"><li>A contract allows an action based on a signature but <strong>fails to check that the signature is valid</strong> or has not been used before.</li></td><td style="text-align: left"><li>Use a <strong>nonce to prevent signature replay attacks</strong>.</li><li>Use well-audited libraries for <strong>signature verification</strong> (e.g., OpenZeppelin's <code>ECDSA</code> library).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-432-incomplete-signature-schemes"><a class="header" href="#bwc-432-incomplete-signature-schemes">BWC 4.3.2: Incomplete Signature Schemes</a></h3></td><td style="text-align: left"><strong>Flaws in the implementation of transaction signing cryptography</strong>, such as vulnerability to signature malleability or improper use of EIP-712.</td><td style="text-align: left"><li>An attacker can <strong>slightly modify a valid signature</strong> without invalidating it, potentially causing issues in contracts that rely on the signature hash.</li></td><td style="text-align: left"><li>Use <strong>EIP-712</strong> for structured, typed data signing to prevent phishing and replay attacks across different contracts.</li><li>Ensure the signer address recovered from <strong><code>ecrecover</code> is not the zero address</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-44-address-spoofing-in-meta-transactions"><a class="header" href="#bwc-44-address-spoofing-in-meta-transactions">BWC 4.4: Address Spoofing in Meta-Transactions</a></h2></td><td style="text-align: left"><h3 id="bwc-441-erc-2771--multicall"><a class="header" href="#bwc-441-erc-2771--multicall">BWC 4.4.1: ERC-2771 + Multicall</a></h3></td><td style="text-align: left">A vulnerability where a contract uses both <strong>ERC-2771 for meta-transactions and a <code>Multicall</code>-type contract as its trusted forwarder</strong>. If the forwarder does not properly append the original caller's address to the <code>callData</code> of each sub-call, an attacker can control the data that the receiving contract mistakes for the caller's address, thus impersonating any account.</td><td style="text-align: left"><li>An attacker calls a vulnerable <code>Multicall</code> forwarder, crafting the <code>callData</code> of a sub-call so that its <strong>last 20 bytes contain the address of the victim</strong> they wish to impersonate (e.g., the contract owner).</li><li>The <code>Multicall</code> contract forwards this <code>callData</code> to the target contract <strong>without appending the real <code>msg.sender</code></strong>.</li><li>The target contract, using <code>ERC2771Context</code>, <strong>extracts the last 20 bytes</strong> of the received <code>callData</code>, trusting it to be the sender's address. It then grants the attacker the privileges of the impersonated victim.</li></td><td style="text-align: left"><li>Ensure any trusted forwarder correctly <strong>appends the original <code>msg.sender</code></strong> to the end of the <code>callData</code> for all sub-calls (e.g., <code>abi.encodePacked(call.callData, msg.sender)</code>).</li><li>Use <strong>standard, audited implementations</strong> of <code>Multicall</code> and <code>ERC2771Context</code> from libraries like OpenZeppelin, which have patched this specific interaction.</li><li>Avoid using generic, <strong>non-ERC2771-compliant <code>Multicall</code></strong> contracts as trusted forwarders.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-45-inconsistent-data-interpretation"><a class="header" href="#bwc-45-inconsistent-data-interpretation">BWC 4.5: Inconsistent Data Interpretation</a></h2></td><td style="text-align: left"><h3 id="bwc-451-parser-differential--inconsistent-validation"><a class="header" href="#bwc-451-parser-differential--inconsistent-validation">BWC 4.5.1: Parser Differential / Inconsistent Validation</a></h3></td><td style="text-align: left"><strong>Occurs when different components or execution paths interpret or validate the same input data differently.</strong> This creates a security gap where checks enforced in one context (e.g., immediate execution) are missing or implemented differently in another (e.g., retry logic, off-chain indexing vs on-chain execution).</td><td style="text-align: left"><li><strong>Path Bypassing:</strong> Forcing a transaction into a secondary state (like "Retriable" in a bridge) to exploit the fact that the secondary execution path lacks the validation checks present in the primary path.</li><li><strong>Format Discrepancies:</strong> Exploiting differences in how two libraries decode the same data (e.g., a JSON parser vs a Solidity decoder) to smuggle malicious payloads.</li></td><td style="text-align: left"><li><strong>Centralize Validation:</strong> Use a single, shared library or modifier for validation across all execution paths.</li><li><strong>Canonical Data formats:</strong> Ensure strictly typed and canonical data formats are used throughout the lifecycle of a message.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-5-economic--game-theoretic-vulnerabilities"><a class="header" href="#bwc-5-economic--game-theoretic-vulnerabilities">BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-51-miner-extractable-value-mev-attacks"><a class="header" href="#bwc-51-miner-extractable-value-mev-attacks">BWC 5.1: Miner Extractable Value (MEV) Attacks</a></h2></td><td style="text-align: left"><h3 id="bwc-511-front-running"><a class="header" href="#bwc-511-front-running">BWC 5.1.1: Front-Running</a></h3></td><td style="text-align: left"><strong>Placing a transaction in the queue before a known future transaction</strong> to exploit the order of execution. This is often possible when a transaction's input data contains sensitive information (like a password or a solution to a puzzle) that is publicly visible in the mempool.</td><td style="text-align: left"><li><strong>Sniffing sensitive data</strong> (e.g., passwords, answers to puzzles) from transaction input data in the public mempool and using it in a competing transaction with a higher gas fee.</li></td><td style="text-align: left"><li><strong>Never pass cleartext secrets</strong> (like passwords or private keys) as function arguments. Sensitive data in a transaction's payload is publicly visible.</li><li>Use a <strong>Commit-Reveal Scheme</strong> to prevent exposing the secret before execution.</li><li>Use <strong>Off-Chain Signatures (EIP-712)</strong> where a user signs a message containing the secret, and the contract verifies the signature.</li><li>Make use of offchain <strong>MEV protection mechanisms</strong> such as Flashbots.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-512-back-running"><a class="header" href="#bwc-512-back-running">BWC 5.1.2: Back-Running</a></h3></td><td style="text-align: left"><strong>Placing a transaction immediately after a targeted transaction</strong> to exploit its effects.</td><td style="text-align: left"><li>Observing a large swap on a DEX and immediately placing a trade to <strong>profit from the price slippage</strong> caused by it.</li></td><td style="text-align: left"><li>Make use of offchain <strong>MEV protection mechanisms</strong> such as Flashbots.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-513-sandwich-attacks"><a class="header" href="#bwc-513-sandwich-attacks">BWC 5.1.3: Sandwich Attacks</a></h3></td><td style="text-align: left"><strong>Combining front-running and back-running</strong> to trap a victim's transaction and extract value.</td><td style="text-align: left"><li>An attacker <strong>front-runs a victim's buy order</strong> to drive the price up, lets the victim's trade execute at the higher price, and then <strong>back-runs it with a sell order</strong> to profit from the price difference.</li></td><td style="text-align: left"><li>Use <strong>DEX aggregators</strong> that offer sandwich protection.</li><li>Set a <strong>tight slippage tolerance</strong> on trades.</li><li>Use <strong>private transaction relays</strong> (e.g., Flashbots).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-52-price--liquidity-manipulation"><a class="header" href="#bwc-52-price--liquidity-manipulation">BWC 5.2: Price &amp; Liquidity Manipulation</a></h2></td><td style="text-align: left"><h3 id="bwc-521-price-manipulation"><a class="header" href="#bwc-521-price-manipulation">BWC 5.2.1: Price Manipulation</a></h3></td><td style="text-align: left"><strong>Artificially influencing asset prices</strong> through coordinated market actions to exploit DApp mechanisms, liquidate other traders, or create false impressions of market activity.</td><td style="text-align: left"><li><strong>Wash Trading:</strong> Generating massive, artificial trading volume using bots to create the illusion of high demand and liquidity.</li><li><strong>Engineered Short Squeezes:</strong> Using a large, often Sybil-acquired token supply to intentionally drive up the spot price and trigger mass liquidations of short positions.</li><li>Using a <strong>flash loan to execute a large trade</strong> on a DEX, momentarily skewing the price, and then using that manipulated price in another protocol to take out an unfair loan.</li></td><td style="text-align: left"><li>Use <strong>manipulation-resistant oracles</strong> (e.g., TWAP oracles).</li><li><strong>Don't use on-chain DEX spot prices</strong> as a direct price feed.</li><li>Monitor for <strong>anomalous trading patterns</strong>, such as statistically improbable volume or liquidity spikes that do not align with user growth.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-522-first-deposit--inflation-attack"><a class="header" href="#bwc-522-first-deposit--inflation-attack">BWC 5.2.2: First Deposit / Inflation Attack</a></h3></td><td style="text-align: left"><strong>Exploiting initialization or low-liquidity conditions</strong> in liquidity pools or token vaults (e.g., ERC4626) to manipulate the share price and claim a disproportionate share of assets.</td><td style="text-align: left"><li><strong>Front-running the first depositor</strong> with a tiny amount of assets to control the initial share price.</li><li><strong>Donating assets to a vault</strong> to inflate the value of existing shares. This causes subsequent depositors' assets to be rounded down, resulting in them receiving fewer or zero shares.</li></td><td style="text-align: left"><li><strong>Initial Liquidity:</strong> The deployer should securely deposit a substantial amount of initial assets to make inflation attacks economically unfeasible.</li><li><strong>Slippage Control:</strong> Revert transactions if the number of shares received is outside an acceptable slippage range.</li><li><strong>Virtual Liquidity:</strong> Implement logic that behaves as if the pool has a minimum amount of "virtual" assets and shares, preventing rounding errors on initial deposits.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-523-hardcoded-or-assumed-asset-price"><a class="header" href="#bwc-523-hardcoded-or-assumed-asset-price">BWC 5.2.3: Hardcoded or Assumed Asset Price</a></h3></td><td style="text-align: left">Using a <strong>fixed, hardcoded price for an asset</strong>, or implicitly assuming a fixed price ratio (e.g., assuming 1 USDC = 1 USD), instead of using a dynamic oracle feed. This creates arbitrage opportunities when the asset's real market price deviates from the assumed price.</td><td style="text-align: left"><li>Exploiting <strong>stablecoin de-peg events</strong> to buy protocol assets at a discount or borrow against them at an inflated value.</li></td><td style="text-align: left"><li>Use <strong>reliable price oracles</strong> for all assets involved in value calculations, including those presumed to be stable.</li><li>For any exchange between Asset A and Asset B, the protocol must <strong>dynamically determine the price</strong> of A relative to B.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-524-over-leverage--liquidation-spirals"><a class="header" href="#bwc-524-over-leverage--liquidation-spirals">BWC 5.2.4: Over-Leverage &amp; Liquidation Spirals</a></h3></td><td style="text-align: left">The protocol's design encourages or allows for <strong>excessive leverage</strong>, making the system fragile and susceptible to cascading liquidations ("death spirals") during periods of high market volatility. The risk is amplified when the collateral used is itself volatile, illiquid, or subject to de-pegging.</td><td style="text-align: left"><li>A significant market event triggers an initial price drop, causing the first wave of liquidations.</li><li>These forced sales create further downward price pressure on the collateral, leading to more liquidations in a self-reinforcing feedback loop.</li><li>Protocols with insufficient liquidity or flawed auction mechanisms are unable to handle the cascade, resulting in bad debt or insolvency.</li></td><td style="text-align: left"><li><strong>Protocol Mitigation:</strong> Implement conservative collateralization ratios and debt ceilings. Use circuit breakers to pause liquidations during extreme volatility. Design robust liquidation engines that can handle high-stress scenarios without causing market collapse.</li><li><strong>User Mitigation:</strong> Exercise extreme caution with leverage. Understand the liquidation parameters and the risks of the collateral being used. Avoid high leverage, particularly during periods of market instability or with volatile assets.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-53-transaction-execution-risks"><a class="header" href="#bwc-53-transaction-execution-risks">BWC 5.3: Transaction Execution Risks</a></h2></td><td style="text-align: left"><h3 id="bwc-531-lack-of-slippage-control"><a class="header" href="#bwc-531-lack-of-slippage-control">BWC 5.3.1: Lack of Slippage Control</a></h3></td><td style="text-align: left"><strong>Missing or insufficient protection against price movement</strong> between the time a transaction is submitted and when it is executed, making it vulnerable to sandwich attacks.</td><td style="text-align: left"><li>A user submits a trade on a DEX without specifying a maximum slippage, allowing an attacker to execute the trade at a <strong>much worse price</strong>.</li></td><td style="text-align: left"><li>DApp front-ends should enforce a <strong>default slippage tolerance</strong> and allow users to customize it.</li><li>Smart contracts should allow users to specify a <strong>minimum output amount or maximum input amount</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-54-systemic--network-level-economic-risks"><a class="header" href="#bwc-54-systemic--network-level-economic-risks">BWC 5.4: Systemic &amp; Network-Level Economic Risks</a></h2></td><td style="text-align: left"><h3 id="bwc-541-cascade-failure-from-network-congestion"><a class="header" href="#bwc-541-cascade-failure-from-network-congestion">BWC 5.4.1: Cascade Failure from Network Congestion</a></h3></td><td style="text-align: left">A systemic failure where <strong>extreme network congestion</strong> (leading to high gas fees) and rapid asset price volatility cause critical off-chain infrastructure (like oracles and keeper bots) to fail or lag. This can lead to cascading liquidations, failed auctions, or other unintended economic consequences because the system's assumptions about timely and affordable transaction inclusion are violated.</td><td style="text-align: left"><li>During a market crash, <strong>high gas prices prevent liquidation/auction keeper bots</strong> from submitting bids, as their hardcoded or non-adaptive gas price settings are too low.</li><li><strong>Price oracles lag</strong> in updating on-chain prices due to network congestion, causing a sudden, large price adjustment that triggers mass liquidations simultaneously.</li><li>An attacker, prepared for high gas conditions, can <strong>win collateral auctions for little to no cost</strong> because other bidders are effectively priced out of the network (DoS via gas).</li></td><td style="text-align: left"><li>Ensure critical off-chain software (keepers, oracles) is <strong>robust, audited, and designed to function under extreme network congestion</strong> and gas price volatility.</li><li>Encourage a <strong>diverse and decentralized ecosystem of keeper bots</strong> through grants or built-in incentives to avoid single points of failure.</li><li>Implement more <strong>robust on-chain auction mechanisms</strong>, such as starting with a reserve price or using mechanisms less sensitive to gas prices (e.g., Dutch auctions).</li><li>Design <strong>liquidation thresholds and system parameters</strong> to handle sudden, severe price drops without causing a death spiral.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-6-arithmetic--numeric-vulnerabilities"><a class="header" href="#bwc-6-arithmetic--numeric-vulnerabilities">BWC 6: Arithmetic &amp; Numeric Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-61-integer-overflow--underflow"><a class="header" href="#bwc-61-integer-overflow--underflow">BWC 6.1: Integer Overflow &amp; Underflow</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Exceeding the maximum or minimum value</strong> for an integer type, causing it to wrap around.</td><td style="text-align: left"><li>An attacker transfers a large number of tokens to a contract, causing its balance to <strong>overflow and wrap around</strong> to a small number.</li></td><td style="text-align: left"><li>Use modern Solidity versions (&gt;=0.8.0), which have <strong>built-in overflow and underflow checks</strong>.</li><li>Use libraries like OpenZeppelin's <strong><code>SafeMath</code></strong> for older Solidity versions.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-62-precision-loss--rounding-errors"><a class="header" href="#bwc-62-precision-loss--rounding-errors">BWC 6.2: Precision Loss &amp; Rounding Errors</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Issues arising from <strong>integer division, order of operations</strong> (division before multiplication), or inconsistent decimal scaling.</td><td style="text-align: left"><li>A calculation involving division results in a <strong>rounding error</strong> that can be exploited over many transactions to drain funds.</li></td><td style="text-align: left"><li>Perform <strong>multiplication before division</strong> to maintain precision.</li><li>Be mindful of the <strong>decimal precision</strong> of different tokens when performing calculations.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-63-unsafe-type-casting"><a class="header" href="#bwc-63-unsafe-type-casting">BWC 6.3: Unsafe Type Casting</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Improper or unchecked conversion between numeric types</strong>, potentially leading to overflow or precision loss.</td><td style="text-align: left"><li><strong>Casting a <code>uint256</code> to a <code>uint128</code></strong> without checking if the value fits, leading to truncation and unexpected behavior.</li></td><td style="text-align: left"><li><strong>Validate that a value is within the bounds</strong> of the target type before casting.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-64-calculation-errors"><a class="header" href="#bwc-64-calculation-errors">BWC 6.4: Calculation Errors</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>General mathematical mistakes in contract logic</strong>, such as in liquidity or reward formulas.</td><td style="text-align: left"><li>A <strong>simple typo or incorrect formula</strong> in the code that calculates interest payments or rewards.</li></td><td style="text-align: left"><li><strong>Thoroughly test</strong> all mathematical logic with a wide range of inputs.</li><li>Get an <strong>external audit</strong> to review all calculations.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-65-inconsistent-scaling-bugs"><a class="header" href="#bwc-65-inconsistent-scaling-bugs">BWC 6.5: Inconsistent Scaling Bugs</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Occurs when a smart contract performs math on numbers that have <strong>different decimal precisions</strong> (e.g., mixing a token with 6 decimals and one with 18) without proper normalization.</td><td style="text-align: left"><li>A contract incorrectly adds the value of a 6-decimal USDC token to an 18-decimal DAI token, leading to a <strong>massive accounting error</strong>.</li></td><td style="text-align: left"><li><strong>Normalize all token amounts</strong> to a consistent precision (e.g., 18 decimals) before performing any mathematical operations.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-7-low-level--evm-specific-vulnerabilities"><a class="header" href="#bwc-7-low-level--evm-specific-vulnerabilities">BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-71-unchecked-return-values"><a class="header" href="#bwc-71-unchecked-return-values">BWC 7.1: Unchecked Return Values</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Failing to verify the success status of external calls</strong>, leading the contract to incorrectly assume success when the call actually failed.</td><td style="text-align: left"><li>A contract calls <code>ERC20.approve()</code> but <strong>doesn't check the boolean return value</strong>. The approval fails silently, but the contract proceeds as if it succeeded.</li></td><td style="text-align: left"><li>Use OpenZeppelin's <strong><code>SafeERC20</code> library</strong>, which handles return value checks.</li><li>Explicitly check the <strong><code>success</code> boolean</strong> returned from low-level calls.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-72-unsafe-storage--memory-handling"><a class="header" href="#bwc-72-unsafe-storage--memory-handling">BWC 7.2: Unsafe Storage &amp; Memory Handling</a></h2></td><td style="text-align: left"><h3 id="bwc-721-unsafe-storage-use"><a class="header" href="#bwc-721-unsafe-storage-use">BWC 7.2.1: Unsafe Storage Use</a></h3></td><td style="text-align: left"><strong>Improper handling of contract storage slots</strong>, leading to collisions or data corruption, especially in proxy patterns.</td><td style="text-align: left"><li>An upgradeable contract adds new state variables that <strong>overwrite existing storage slots</strong> from the proxy contract.</li></td><td style="text-align: left"><li>Follow a standard for <strong>storage layout in upgradeable contracts</strong> (e.g., EIP-1967).</li><li>Use tools to check for <strong>storage collisions</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-722-improper-deletion-of-complex-types"><a class="header" href="#bwc-722-improper-deletion-of-complex-types">BWC 7.2.2: Improper Deletion of Complex Types</a></h3></td><td style="text-align: left">Vulnerabilities arising from the <strong>improper deletion of complex data types</strong> (e.g., arrays of mappings, structs containing mappings). Operations like <code>delete</code> may not clear the underlying storage for nested mappings, leading to old data persisting and being misinterpreted later.</td><td style="text-align: left"><li><strong>Deleting an array of mappings and re-allocating it</strong>, causing old values to reappear as if they were valid new entries.</li><li><strong>Deleting a struct containing a dynamic array</strong> can lead to unexpected behavior or data corruption in older Solidity versions.</li></td><td style="text-align: left"><li><strong>Avoid deleting structs with complex data types</strong>; if necessary, implement a function to explicitly zero out all members.</li><li>For iterable data, use libraries that provide <strong>key tracking</strong> to allow for proper deletion.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-723-broken-eip-1153-transient-storage-use"><a class="header" href="#bwc-723-broken-eip-1153-transient-storage-use">BWC 7.2.3: Broken EIP-1153 Transient Storage Use</a></h3></td><td style="text-align: left"><strong>Misuse of transient storage (<code>TSTORE</code>, <code>TLOAD</code>)</strong>, which can enable reentrancy or state corruption due to improper clearing or assumptions about its lifecycle.</td><td style="text-align: left"><li>A contract uses transient storage as a reentrancy lock but <strong>fails to clear it properly</strong> on all execution paths, allowing a reentrancy attack.</li></td><td style="text-align: left"><li>Ensure <strong>transient storage slots are cleared</strong> after use.</li><li>Understand that transient storage is cleared at the <strong>end of a transaction</strong>, not a call.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-73-weak-cryptographic-primitives"><a class="header" href="#bwc-73-weak-cryptographic-primitives">BWC 7.3: Weak Cryptographic Primitives</a></h2></td><td style="text-align: left"><h3 id="bwc-731-weak-random-number-generation"><a class="header" href="#bwc-731-weak-random-number-generation">BWC 7.3.1: Weak Random Number Generation</a></h3></td><td style="text-align: left">Using <strong>predictable or manipulable sources of on-chain entropy</strong> (e.g., <code>block.timestamp</code>, <code>blockhash</code>).</td><td style="text-align: left"><li>A lottery contract uses <strong><code>block.timestamp</code> to determine the winner</strong>, allowing a miner to influence the outcome.</li></td><td style="text-align: left"><li>Use a <strong>commit-reveal scheme</strong>.</li><li>Use a <strong>verifiable random function (VRF)</strong> from an oracle like Chainlink.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-732-malleable-ecrecover"><a class="header" href="#bwc-732-malleable-ecrecover">BWC 7.3.2: Malleable ecrecover</a></h3></td><td style="text-align: left">Vulnerabilities in <strong>signature recovery (<code>ecrecover</code>)</strong> allowing for signature reuse or forgery if not handled correctly.</td><td style="text-align: left"><li>An attacker can <strong>slightly modify a valid signature</strong> without invalidating it, which can be used to bypass replay protection that relies on the signature hash.</li></td><td style="text-align: left"><li>Use OpenZeppelin's <strong><code>ECDSA</code> library</strong>, which protects against signature malleability.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-733-second-preimage-attacks"><a class="header" href="#bwc-733-second-preimage-attacks">BWC 7.3.3: Second PreImage Attacks</a></h3></td><td style="text-align: left"><strong>Cryptographic vulnerabilities allowing for collisions in hash functions</strong> used by the contract, although this is generally considered infeasible with modern hash functions like SHA-256.</td><td style="text-align: left"><li>An attacker finds <strong>two different inputs that produce the same hash</strong>, potentially bypassing a check that relies on the hash.</li></td><td style="text-align: left"><li>Use <strong>strong, standard hash functions</strong> (e.g., <code>keccak256</code>).</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-734-forgetting-to-blind-polynomials-in-zk-protocols"><a class="header" href="#bwc-734-forgetting-to-blind-polynomials-in-zk-protocols">BWC 7.3.4: Forgetting to Blind Polynomials in ZK Protocols</a></h3></td><td style="text-align: left"><strong>Weaknesses in zero-knowledge proof implementations</strong> that expose underlying data by failing to properly randomize cryptographic commitments.</td><td style="text-align: left"><li>A ZK-SNARK implementation that <strong>does not properly blind polynomials</strong> can leak information about the secret inputs.</li></td><td style="text-align: left"><li>Use <strong>well-audited, standard implementations</strong> of zero-knowledge proof systems.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-735-insecure-cryptographic-construction"><a class="header" href="#bwc-735-insecure-cryptographic-construction">BWC 7.3.5: Insecure Cryptographic Construction</a></h3></td><td style="text-align: left"><strong>Using sound cryptographic primitives</strong> (e.g., <code>keccak256</code>) but combining them in a way that creates a flawed or insecure algorithm. This is a design-level cryptographic flaw rather than a weakness in the primitive itself.</td><td style="text-align: left"><li>Using <strong>XOR to combine multiple hashes</strong> into a single fingerprint, which allows for collision attacks.</li></td><td style="text-align: left"><li>Use <strong>standard, well-vetted cryptographic constructions</strong> for commitments, such as Merkle trees or simple hash concatenation.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-74-client--compiler-correctness"><a class="header" href="#bwc-74-client--compiler-correctness">BWC 7.4: Client &amp; Compiler Correctness</a></h2></td><td style="text-align: left"><h3 id="bwc-741-incorrect-vm-gas-charges"><a class="header" href="#bwc-741-incorrect-vm-gas-charges">BWC 7.4.1: Incorrect VM Gas Charges</a></h3></td><td style="text-align: left">Logic that becomes vulnerable due to <strong>miscalculations of transaction execution costs</strong> or changes in gas costs from network upgrades.</td><td style="text-align: left"><li>A contract's logic relies on a <strong>specific gas cost for an operation</strong>, which then changes in a hard fork, breaking the contract.</li></td><td style="text-align: left"><li>Avoid writing logic that depends on <strong>specific gas costs</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-742-compiler-bug"><a class="header" href="#bwc-742-compiler-bug">BWC 7.4.2: Compiler Bug</a></h3></td><td style="text-align: left">A <strong>bug in the compiler</strong> that causes it to generate incorrect bytecode, or vulnerabilities arising from improper compiler version management.</td><td style="text-align: left"><li><strong>Floating Pragma:</strong> Using a floating pragma (e.g., <code>^0.8.0</code>) allows a contract to be deployed with <strong>different compiler versions</strong>, some of which may contain bugs.</li><li><strong>Outdated Version:</strong> Compiling a contract with an <strong>older compiler version</strong> that has known, publicly disclosed vulnerabilities.</li></td><td style="text-align: left"><li><strong>Lock the Pragma:</strong> Use a <strong>fixed compiler version</strong> (e.g., <code>pragma solidity 0.8.21;</code>) in source code to ensure deterministic builds.</li><li>Always use the <strong>latest, well-audited version</strong> of the Solidity compiler.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-8-denial-of-service-dos-vulnerabilities"><a class="header" href="#bwc-8-denial-of-service-dos-vulnerabilities">BWC 8: Denial of Service (DoS) Vulnerabilities</a></h1></td><td style="text-align: left"><h2 id="bwc-81-dos-via-external-calls"><a class="header" href="#bwc-81-dos-via-external-calls">BWC 8.1: DoS via External Calls</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Blocking contract functionality through external calls</strong> to malicious or non-functional contracts. This often occurs when using low-gas-forwarding functions like <code>.transfer()</code> to send Ether to a contract that requires more gas for its fallback function than is provided.</td><td style="text-align: left"><li>Using <strong><code>.transfer()</code> or <code>.send()</code></strong> to a smart contract wallet (e.g., Gnosis Safe) whose fallback function consumes more than the 2300 gas stipend, causing the transaction to revert.</li><li>If this call is part of a critical workflow like withdrawals, it can <strong>permanently lock funds</strong> for users of contract wallets.</li></td><td style="text-align: left"><li><strong>Avoid using <code>.transfer()</code> and <code>.send()</code></strong> for sending Ether.</li><li>Use <strong><code>.call{value: ...}("")</code></strong> instead, as it forwards all available gas.</li><li>Prefer <strong>pull-over-push patterns</strong> for payments, where users call a function to withdraw their funds rather than having the contract send it to them automatically.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-82-dos-via-malicious-receivers"><a class="header" href="#bwc-82-dos-via-malicious-receivers">BWC 8.2: DoS via Malicious Receivers</a></h2></td><td style="text-align: left"></td><td style="text-align: left">A <strong>recipient contract designed to revert or consume excessive gas</strong> when receiving tokens or Ether, causing the sender's transaction to fail.</td><td style="text-align: left"><li>An auction contract that automatically sends funds to the previous highest bidder can be blocked if a malicious bidder sets their address to a <strong>contract that reverts on receiving funds</strong>.</li></td><td style="text-align: left"><li>Favor <strong>pull payments</strong> over push payments.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-83-dos-via-non-reentrant-locks"><a class="header" href="#bwc-83-dos-via-non-reentrant-locks">BWC 8.3: DoS via Non-Reentrant Locks</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Exploiting reentrancy guards to permanently or temporarily lock functions</strong> if the lock is not properly cleared on all execution paths.</td><td style="text-align: left"><li>A function with a reentrancy guard calls an external contract that reverts. If the <strong>lock is not unwound</strong>, the function may be permanently locked.</li></td><td style="text-align: left"><li>Use <strong><code>try/catch</code> blocks</strong> to ensure reentrancy locks are always cleared, even if an external call fails.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-84-dos-via-numeric-calculation"><a class="header" href="#bwc-84-dos-via-numeric-calculation">BWC 8.4: DoS via Numeric Calculation</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Causing <strong>numeric underflows, overflows, or division-by-zero errors</strong> that block contract execution.</td><td style="text-align: left"><li>An attacker forces a variable used as a divisor to zero, causing all future transactions that use that calculation to <strong>revert</strong>.</li></td><td style="text-align: left"><li>Add checks to prevent <strong>division by zero</strong>.</li><li>Use <strong>safe math libraries</strong> to prevent overflows and underflows.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-85-dos-via-block-gas-limit"><a class="header" href="#bwc-85-dos-via-block-gas-limit">BWC 8.5: DoS via Block Gas Limit</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Crafting operations that <strong>exceed the block gas limit</strong>, making certain state transitions impossible, often by making an array or loop too large.</td><td style="text-align: left"><li>An attacker adds many addresses to a distribution list, causing the function that iterates through the list to distribute rewards to <strong>run out of gas</strong>.</li></td><td style="text-align: left"><li>Avoid <strong>unbounded loops</strong>.</li><li>Provide ways for users to <strong>withdraw or claim funds individually</strong> rather than relying on a single distribution transaction.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-86-dos-via-hook-griefing"><a class="header" href="#bwc-86-dos-via-hook-griefing">BWC 8.6: DoS via Hook Griefing</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Exploitation of token standard callbacks</strong> (e.g., ERC777/721/1155) to cause denial of service by making them revert.</td><td style="text-align: left"><li>An attacker registers a malicious contract as a token recipient that always <strong>reverts in its <code>onERC721Received</code> hook</strong>, preventing transfers to that address.</li></td><td style="text-align: left"><li>Be aware of the potential for hooks to revert when interacting with these <strong>token standards</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-87-dos-via-return-data-bomb"><a class="header" href="#bwc-87-dos-via-return-data-bomb">BWC 8.7: DoS via Return Data Bomb </a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Exploitation of unbounded return data from an external call</strong> to cause an out-of-gas error when the data is copied to memory.</td><td style="text-align: left"><li>A contract calls an external malicious contract that returns a <strong>very large amount of data</strong>, causing the calling contract to run out of gas when it tries to process the return data.</li></td><td style="text-align: left"><li>If possible, <strong>limit the size of return data</strong> from external calls.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-88-dos-in-cross-chain-messaging-protocols"><a class="header" href="#bwc-88-dos-in-cross-chain-messaging-protocols">BWC 8.8: DoS in Cross-Chain Messaging Protocols</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Specific vulnerabilities in protocols like LayerZero</strong> or their integrations that can halt message passing or cause messages to be delivered incorrectly.</td><td style="text-align: left"><li>An attacker exploits a bug in the relayer or oracle configuration of a cross-chain protocol to <strong>prevent messages from being confirmed</strong> on the destination chain.</li></td><td style="text-align: left"><li>Use <strong>well-audited, reputable cross-chain messaging protocols</strong>.</li><li>Implement monitoring to detect <strong>stalled or failed cross-chain messages</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-89-dos-via-unreliable-on-chain-checks"><a class="header" href="#bwc-89-dos-via-unreliable-on-chain-checks">BWC 8.9: DoS via Unreliable On-Chain Checks</a></h2></td><td style="text-align: left"></td><td style="text-align: left">A denial-of-service attack where an attacker exploits <strong>unreliable on-chain data sources or checks</strong> to block critical operations. A common example is manipulating the state of an address to make a check like <code>address.codehash</code> return an unexpected value, thereby preventing contract deployment.</td><td style="text-align: left"><li><strong>Sending 1 wei</strong> to a pre-determined contract address to change its codehash from <code>bytes32(0)</code> to <code>keccak256("")</code>.</li></td><td style="text-align: left"><li>Avoid relying on <strong><code>address.codehash</code></strong> to determine if a contract exists. A more reliable check is <code>address.code.length &gt; 0</code>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-810-dos-via-forced-recursion"><a class="header" href="#bwc-810-dos-via-forced-recursion">BWC 8.10: DoS via Forced Recursion</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Occurs when a contract uses a recursive function (a function that calls itself) to iterate through a data structure.</strong> An attacker manipulates the contract's state to create an excessively long chain of data (e.g., nodes in a tree, linked list), forcing the recursive function to exceed the EVM's call stack limit (1024 frames). This causes any transaction calling the function to fail, permanently locking funds or functionality.</td><td style="text-align: left"><li>An attacker repeatedly triggers a state-changing operation with minimal effect (e.g., tiny liquidations) to build a long chain of nodes in a data structure that a recursive function must traverse.</li><li>When a legitimate user tries to access a function that relies on this recursion, the transaction reverts with a "stack too deep" error.</li></td><td style="text-align: left"><li><strong>Use Iteration over Recursion:</strong> For traversing data structures that can grow based on user input, always prefer iterative loops (<code>for</code>, <code>while</code>) over recursive patterns. Iteration does not consume the call stack and is not vulnerable to this attack.</li><li><strong>Implement Depth Limits:</strong> If recursion is unavoidable, implement a hard-coded counter to strictly limit the maximum recursion depth, causing the function to fail safely before hitting the stack limit.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-811-dos-via-front-running-griefing"><a class="header" href="#bwc-811-dos-via-front-running-griefing">BWC 8.11: DoS via Front-Running (Griefing)</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Blocking a user's valid transaction by front-running it</strong> to alter the underlying state conditions required for success. Unlike MEV, the attacker does not necessarily profit; the goal is to cause the victim's transaction to revert. A common vector is <strong>"Permit Griefing,"</strong> where an attacker observes a transaction containing a signed permit, extracts the signature, and submits it independently. The permit is executed, consuming the nonce. When the victim's transaction attempts to execute the permit again, it reverts due to the invalid nonce, failing the entire operation.</td><td style="text-align: left"><li><strong>Permit Griefing:</strong> Front-running a transaction that calls <code>permit()</code> by submitting the signature separately, causing the user's batch transaction to revert.</li><li><strong>Initialization Griefing:</strong> Front-running the initialization of a contract to set parameters that force the legitimate deployer to redeploy.</li></td><td style="text-align: left"><li><strong>Use Try/Catch:</strong> Wrap calls to <code>permit()</code> in a <code>try/catch</code> block. If the call fails (e.g., nonce already used), verify if the allowance is sufficient and proceed.</li><li><strong>Check State First:</strong> Check if the necessary state change (e.g., allowance increase) has already occurred before attempting the state-changing call.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-9-emerging-technology-vulnerabilitiesbwc-92-aiml-integration-attacks"><a class="header" href="#bwc-9-emerging-technology-vulnerabilitiesbwc-92-aiml-integration-attacks">BWC 9: Emerging Technology Vulnerabilities<h1></td><td style="text-align: left"><h2>BWC 9.2: AI/ML Integration Attacks</a></h1></td><td style="text-align: left"><h3 id="bwc-921-ai-model-poisoning--bias-exploits"><a class="header" href="#bwc-921-ai-model-poisoning--bias-exploits">BWC 9.2.1: AI Model Poisoning &amp; Bias Exploits</a></h3></td><td style="text-align: left">Vulnerabilities arising from the <strong>corruption of an AI/ML model's training data</strong> or the exploitation of its inherent biases. This is an attack on the integrity of the model itself.</td><td style="text-align: left"><li>An attacker could <strong>"poison" the training data</strong> of an AI-powered oracle to make it produce incorrect but seemingly valid outputs.</li><li><strong>Exploiting biases</strong> in a model to cause it to behave in unintended and harmful ways.</li></td><td style="text-align: left"><li>Ensure AI/ML models used in decentralized systems are <strong>robust and have transparent, verifiable inputs and outputs</strong>.</li><li>Implement <strong>continuous monitoring and validation</strong> of model outputs against known ground truths.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-922-ai-prompt-injection--data-exfiltration"><a class="header" href="#bwc-922-ai-prompt-injection--data-exfiltration">BWC 9.2.2: AI Prompt Injection &amp; Data Exfiltration</a></h3></td><td style="text-align: left">Occurs when a system allows <strong>untrusted external data</strong> (e.g., emails, calendar invites, web pages) to be interpreted as trusted commands by an AI agent. The AI is "jailbroken" by malicious data, causing it to perform unauthorized actions or leak sensitive information.</td><td style="text-align: left"><li><strong>Data Source Poisoning:</strong> An attacker injects a malicious prompt into a data source that an AI agent will later read (e.g., a calendar invite, email, or document).</li><li><strong>Hijacking User Sessions:</strong> When a legitimate user prompts the AI to interact with the poisoned data source (e.g., "summarize my upcoming events"), the AI executes the hidden malicious command.</li><li><strong>Exfiltration &amp; Malicious Actions:</strong> The malicious command can instruct the AI to exfiltrate private user data (from emails, documents) and send it to an attacker, or to subvert on-chain AI governance by tricking it into allocating funds or voting maliciously.</li></td><td style="text-align: left"><li><strong>Strict Data/Instruction Separation:</strong> Design systems to maintain a robust separation between trusted instructions (user prompts) and untrusted external data. An AI should treat external data as content to be analyzed, not as commands to be executed.</li><li><strong>Avoid Naive AI Governance:</strong> Do not hardcode a single AI model with direct control over critical functions like fund allocation.</li><li><strong>Institutional Design (Info Finance):</strong> Create open, competitive environments where multiple AI models can be submitted and are subject to spot-checking and evaluation by human juries, creating incentives for flaw discovery.</li><li><strong>User-Side Caution:</strong> Users should be extremely cautious when granting AI agents broad, read-write access to sensitive personal data sources.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-93-hardware-level-exploits"><a class="header" href="#bwc-93-hardware-level-exploits">BWC 9.3: Hardware-Level Exploits</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Attacks that target the <strong>underlying hardware</strong> on which nodes or validators run, such as Rowhammer or Spectre, to corrupt memory or leak sensitive data.</td><td style="text-align: left"><li>A sophisticated attacker uses a <strong>hardware vulnerability</strong> to extract validator private keys from a server's memory.</li></td><td style="text-align: left"><li>Use <strong>secure, enterprise-grade hardware</strong>.</li><li>Keep server firmware and software <strong>up-to-date with security patches</strong>.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-10-network--consensus-evolution-attacks"><a class="header" href="#bwc-10-network--consensus-evolution-attacks">BWC 10: Network &amp; Consensus Evolution Attacks</a></h1></td><td style="text-align: left"><h2 id="bwc-101-advanced-p2p-network-attacks"><a class="header" href="#bwc-101-advanced-p2p-network-attacks">BWC 10.1: Advanced P2P Network Attacks</a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Sophisticated attacks on the peer-to-peer networking layer</strong> of a blockchain, such as eclipse attacks or network partitioning, to isolate nodes or disrupt consensus.</td><td style="text-align: left"><li>An attacker controls all of a node's incoming and outgoing connections, <strong>feeding it false information</strong> about the state of the network.</li></td><td style="text-align: left"><li><strong>Increase the number of peer connections</strong> for nodes.</li><li>Use <strong>diverse and decentralized node discovery mechanisms</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-102-novel-consensus-mechanism-exploits"><a class="header" href="#bwc-102-novel-consensus-mechanism-exploits">BWC 10.2: Novel Consensus Mechanism Exploits </a></h2></td><td style="text-align: left"></td><td style="text-align: left"><strong>Vulnerabilities specific to newer or more complex consensus mechanisms</strong> beyond traditional Proof-of-Work or Proof-of-Stake.</td><td style="text-align: left"><li>Exploiting a flaw in the <strong>finality gadget</strong> of a PoS chain to cause a re-organization of the chain.</li></td><td style="text-align: left"><li><strong>Rigorous academic peer review and formal verification</strong> of new consensus protocols.</li><li><strong>Extensive testing on public testnets</strong> before mainnet deployment.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-103-cross-protocol-interoperability-attacks"><a class="header" href="#bwc-103-cross-protocol-interoperability-attacks">BWC 10.3: Cross-Protocol Interoperability Attacks </a></h2></td><td style="text-align: left"></td><td style="text-align: left">Vulnerabilities that emerge from the <strong>complex and often unaudited interactions between different blockchain protocols</strong>, especially in the context of DeFi composability.</td><td style="text-align: left"><li>An attacker combines features from three different DeFi protocols in an <strong>unforeseen way</strong> to create an exploit that would not be possible with any single protocol.</li></td><td style="text-align: left"><li><strong>Deep understanding and auditing</strong> of all integrated protocols.</li><li><strong>Defensive design</strong> that anticipates unexpected interactions.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-104-protocol-upgrade-induced-vulnerabilities"><a class="header" href="#bwc-104-protocol-upgrade-induced-vulnerabilities">BWC 10.4: Protocol Upgrade-Induced Vulnerabilities</a></h2></td><td style="text-align: left"></td><td style="text-align: left">Vulnerabilities that emerge in previously secure contracts when a <strong>network or protocol upgrade</strong> (like an EIP implementation) changes the behavior or security assumptions of the underlying platform. The contract code itself doesn't change, but its execution context does, rendering existing security patterns ineffective.</td><td style="text-align: left"><li>A network upgrade <strong>changes the gas cost of an opcode</strong>, breaking a contract that relied on the old gas cost.</li></td><td style="text-align: left"><li>Contract developers should <strong>stay informed</strong> about upcoming network upgrades.</li><li>Avoid writing code that depends on <strong>specific, hardcoded network behaviors</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1041-eip-7702-delegation-risks"><a class="header" href="#bwc-1041-eip-7702-delegation-risks">BWC 10.4.1: EIP-7702 Delegation Risks</a></h3></td><td style="text-align: left">With the adoption of EIP-7702, Externally Owned Accounts (EOAs) can <strong>temporarily delegate their capabilities</strong> to a smart contract. This blurs the line between EOAs and contracts, breaking fundamental security assumptions. For example, the invariant that <code>tx.origin</code> is always an EOA is no longer true, rendering checks like <code>msg.sender == tx.origin</code> unsafe for reentrancy protection.</td><td style="text-align: left"><li><strong>Reentrancy:</strong> An account can call itself, making <code>msg.sender == tx.origin</code> true, bypassing old reentrancy guards.</li><li><strong>Initialization Front-Running:</strong> An attacker can front-run the delegation and initialize the contract to seize control.</li><li><strong>Storage Collisions:</strong> Switching between delegation contracts without clearing storage can lead to data corruption if storage layouts differ.</li><li><strong>Phishing:</strong> Users can be tricked into delegating to a malicious contract, granting full asset control to an attacker, especially when using a global <code>chain_id=0</code>.</li></td><td style="text-align: left"><li><strong>Reentrancy:</strong> Use audited reentrancy guards (e.g., OpenZeppelin's <code>nonReentrant</code> modifier) instead of <code>tx.origin</code> checks.</li><li><strong>Initialization:</strong> Secure initialization by requiring user signatures on parameters (<code>initWithSig</code>) or restricting calls to the ERC-4337 <code>EntryPoint</code>.</li><li><strong>Phishing:</strong> Wallets must clearly display the delegation target. Users should only delegate to immutable, audited contracts deployed via <code>CREATE2</code> and avoid <code>chain_id=0</code>.</li><li><strong>Design:</strong> Keep delegation contract logic minimal and well-audited to reduce the attack surface.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1042-constantinople-reentrancy-deprecated"><a class="header" href="#bwc-1042-constantinople-reentrancy-deprecated">BWC 10.4.2: Constantinople Reentrancy (Deprecated)</a></h3></td><td style="text-align: left">A reentrancy vector introduced by a proposed change to <strong><code>SSTORE</code> gas costs</strong> in EIP-1283 for the Constantinople hard fork. This change would have made <code>.send()</code> and <code>.transfer()</code> unsafe, breaking a core security assumption for many contracts. The hard fork was delayed to remove this vulnerability.</td><td style="text-align: left"><li>An attacker could have used the low gas stipend from a <code>.send()</code> or <code>.transfer()</code> to <strong>call back into the victim contract</strong> with enough gas to perform malicious state changes.</li></td><td style="text-align: left"><li>The vulnerability was <strong>mitigated at the protocol level</strong> by reverting the EIP-1283 gas changes before the hard fork was deployed.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1043-call-depth-attack-deprecated"><a class="header" href="#bwc-1043-call-depth-attack-deprecated">BWC 10.4.3: Call Depth Attack (Deprecated)</a></h3></td><td style="text-align: left">A historical DoS vector, mitigated by the EIP-150 hard fork, where an attacker could <strong>recursively call a contract to exhaust the 1024 call depth limit</strong>, causing any subsequent external calls within the transaction to fail.</td><td style="text-align: left"><li>Forcing a legitimate contract's external call (e.g., a payout) to fail by ensuring the <strong>call stack is already at its maximum depth</strong>.</li></td><td style="text-align: left"><li><strong>Mitigated at the protocol level</strong> by EIP-150, which changed gas calculation rules to ensure gas would be consumed long before the call depth limit is reached.</li></td></tr>
<tr><td style="text-align: left"><h1 id="bwc-11-privacy--regulatory-attack-vectors"><a class="header" href="#bwc-11-privacy--regulatory-attack-vectors">BWC 11: Privacy &amp; Regulatory Attack Vectors</a></h1></td><td style="text-align: left"><h2 id="bwc-111-privacy-protocol-compromises"><a class="header" href="#bwc-111-privacy-protocol-compromises">BWC 11.1: Privacy Protocol Compromises</a></h2></td><td style="text-align: left"><h3 id="bwc-1111-anonymity-set-failures"><a class="header" href="#bwc-1111-anonymity-set-failures">BWC 11.1.1: Anonymity Set Failures</a></h3></td><td style="text-align: left">The effectiveness of a privacy protocol (especially mixers) relies on a <strong>large and diverse set of users</strong> to create a "crowd" to hide in. When the number of users or the volume of transactions is low, the anonymity set shrinks, making it easier for observers to statistically link deposits and withdrawals.</td><td style="text-align: left"><li><strong>Transaction graph analysis</strong> on mixers with low liquidity.</li><li><strong>Timing analysis</strong> when few users are active.</li></td><td style="text-align: left"><li>Designing protocols to <strong>incentivize a large and active user base</strong>.</li><li>Users choosing privacy solutions with <strong>demonstrably high volume and usage</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1112-privacy-opsec-failures"><a class="header" href="#bwc-1112-privacy-opsec-failures">BWC 11.1.2: Privacy OPSEC Failures</a></h3></td><td style="text-align: left"><strong>User-side errors in operational security</strong> that undermine the privacy protections offered by a protocol. Even a perfectly designed privacy protocol can be rendered ineffective if the user fails to follow best practices for maintaining their anonymity.</td><td style="text-align: left"><li><strong>Reusing withdrawal addresses</strong>.</li><li><strong>Linking deposit/withdrawal addresses</strong> via on-chain activity or unique amounts.</li><li>Allowing browser extensions to link transactions by <strong>not clearing browser data</strong> (cookies).</li><li><strong>Withdrawing too quickly</strong>, enabling timing-based correlation.</li><li><strong>Exposing the private note</strong> required for withdrawal.</li><li><strong>Revealing IP address</strong> by not using a VPN or Tor.</li></td><td style="text-align: left"><li><strong>User education</strong> on best practices (e.g., using fresh addresses, waiting before withdrawal).</li><li>Using <strong>privacy-preserving tools</strong> like Tor or a reputable VPN.</li><li>Securely <strong>storing private notes</strong> for withdrawal.</li><li>Regularly <strong>clearing browser data</strong>.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"><h2 id="bwc-112-regulatory-weaponization"><a class="header" href="#bwc-112-regulatory-weaponization">BWC 11.2: Regulatory Weaponization</a></h2></td><td style="text-align: left"><h3 id="bwc-1121-patent-trolling"><a class="header" href="#bwc-1121-patent-trolling">BWC 11.2.1: Patent Trolling</a></h3></td><td style="text-align: left"><strong>Using patents, often acquired for the sole purpose of litigation, to file infringement lawsuits against open-source protocols or developers.</strong> The goal is typically to stifle competition, extract settlement fees, or create legal uncertainty, rather than to protect a genuine invention.</td><td style="text-align: left"><li>Filing <strong>broad or frivolous patent infringement lawsuits</strong> against blockchain projects.</li><li><strong>Acquiring patents from defunct companies</strong> to assert them against active developers.</li></td><td style="text-align: left"><li>Proactive use of <strong>defensive patent pools</strong> (e.g., Crypto Open Patent Alliance).</li><li><strong>Challenging the validity of overly broad patents</strong> through legal processes like Inter Partes Review (IPR).</li><li>Maintaining <strong>legal defense funds</strong> to fight frivolous lawsuits.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1122-government-overreach"><a class="header" href="#bwc-1122-government-overreach">BWC 11.2.2: Government Overreach</a></h3></td><td style="text-align: left">The use of state power, including sanctions, subpoenas, or regulatory enforcement actions, to target protocols, developers, or users in a manner that exceeds clear legal mandates or stifles innovation.</td><td style="text-align: left"><li>Intentionally <strong>mischaracterizing a competitor's technology</strong> to fit existing regulatory frameworks (e.g., falsely equivocating a sequencer with a traditional exchange) to invite targeted enforcement.</li><li>A government agency <strong>sanctioning addresses</strong> associated with a privacy protocol without due process.</li><li><strong>Issuing subpoenas</strong> to open-source developers for information about users.</li><li><strong>Classifying decentralized protocols</strong> as unregistered securities or money transmitters.</li></td><td style="text-align: left"><li><strong>Maximizing decentralization</strong> to reduce single points of failure or control.</li><li>Proactive <strong>policy advocacy and education</strong> for regulators to clarify technical nuances.</li><li><strong>Legal challenges</strong> to contest regulatory overreach in court.</li></td></tr>
<tr><td style="text-align: left"></td><td style="text-align: left"></td><td style="text-align: left"><h3 id="bwc-1123-code-is-law-defense-exploitation"><a class="header" href="#bwc-1123-code-is-law-defense-exploitation">BWC 11.2.3: "Code is Law" Defense Exploitation</a></h3></td><td style="text-align: left">An attacker performs an economically harmful exploit and subsequently uses the legal argument that their actions were permissible because they were allowed by the smart contract's code. This strategy exploits the difficulty legal systems face in applying traditional statutes for fraud or manipulation to autonomous, decentralized protocols.</td><td style="text-align: left"><li>Performing an economic attack (e.g., oracle manipulation) and arguing in court that it was a legitimate "highly profitable trading strategy" permitted by the protocol's rules.</li><li>Citing legal precedents where judges have dismissed charges due to a lack of "material misrepresentation" to a smart contract, which cannot be deceived like a human.</li></td><td style="text-align: left"><li><strong>On-Chain Terms of Service:</strong> Implement explicit, legally-vetted Terms of Service that define malicious use and can be referenced in legal proceedings.</li><li><strong>Circuit Breakers &amp; Governance:</strong> Design protocols with emergency pause or intervention mechanisms to demonstrate clear intent to prevent economically harmful outcomes.</li><li><strong>Policy Advocacy:</strong> Engage with policymakers to help develop clear, digitally-native legal frameworks that distinguish between legitimate use and malicious exploitation.</li></td></tr>
</tbody></table>
</div>
<h2 id="general-principles--mitigations"><a class="header" href="#general-principles--mitigations">General Principles &amp; Mitigations</a></h2>
<p>This section outlines high-level principles and common technical mitigations that apply broadly across many vulnerability classes. Specific, targeted mitigations can be found in the main table.</p>
<h3 id="core-security-principles"><a class="header" href="#core-security-principles">Core Security Principles</a></h3>
<ul>
<li><strong>Defense in Depth:</strong> Assume breach. Layer multiple, independent defenses so the failure of one does not compromise the whole system.</li>
<li><strong>Minimize Attack Surface:</strong> Every line of code is a liability. Reduce complexity by eliminating non-essential features, code, and dependencies to shrink the target for attackers.</li>
<li><strong>Least Privilege:</strong> Grant the absolute minimum permissions for the shortest time necessary. Limit both the scope (<em>what</em>) and duration (<em>how long</em>) of any privilege.</li>
<li><strong>Security as a Process:</strong> Security is a continuous process, not a one-time audit. Actively adapt defenses to the evolving threat landscape through ongoing review and learning.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2026-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2026-evm-contract-vulnerability-incidents-classification--analysis">2026 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2026-02-02---14"><a class="header" href="#2026-02-02---14">2026-02-02 - 14</a></h2>
<ul>
<li><strong>Date</strong>: 2026-02-02</li>
<li><strong>Project</strong>: <a href="https://x.com/matchametaxyz">Matcha Meta (SwapNet)</a></li>
<li><strong>Value Lost</strong>: ~$16,800,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.3: Untrusted Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Matcha Meta's SwapNet router was exploited for ~$16.8M (later analysis suggests ~$17M) due to an arbitrary call vulnerability in a closed-source contract.</li>
<li><strong>Vulnerability</strong>: The SwapNet router failed to validate inputs properly, allowing unauthorized arbitrary calls. The attacker used this to force the contract to call <code>transferFrom</code> on various tokens, draining funds from users who had granted infinite approvals to the router.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Reconnaissance</strong>: The attacker identified users with infinite approvals to the SwapNet router.</li>
<li><strong>Execution</strong>: The attacker exploited the arbitrary call flaw to inject calls to <code>token.transferFrom(victim, attacker, amount)</code>, bypassing the router's intended logic.</li>
<li><strong>Laundering</strong>: Funds were swapped for USDC (~$10.5M) and then ~3,655 ETH on Base, which was subsequently bridged to Ethereum Mainnet.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blocksec.com/blog/17m-closed-source-smart-contract-exploit-arbitrary-call-swapnet-aperture">BlockSec Analysis</a></li>
<li><a href="https://timescrypto.com/cryptonews/blockchain/matcha-meta-exploit-drained-16-8m-via-compromised-router/article-21194/">News Article (TimesCrypto)</a></li>
<li><a href="https://x.com/matchametaxyz">Matcha Meta X</a></li>
<li><a href="https://basescan.org/tx/0xc15df1d131e98d24aa0f107a67e33e66cf2ea27903338cc437a3665b6404dd57">Attack Transaction (Basescan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-26---13"><a class="header" href="#2026-01-26---13">2026-01-26 - 13</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-26</li>
<li><strong>Project</strong>: Individual Swap Incident (Illiquid Pool)</li>
<li><strong>Value Lost</strong>: ~$140,000</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.3.1: Lack of Slippage Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.7: Flawed Off-Chain Infrastructure (Potential UI/Routing Failure)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>An individual user suffered a catastrophic loss of ~$140,000 in a single swap transaction, receiving only ~0.09 EUR in return.</li>
<li><strong>Vulnerability</strong>: The transaction was executed through a liquidity pool with insufficient depth (illiquid). The user's transaction likely lacked a proper <code>amountOutMin</code> (slippage protection) parameter, or the interface used failed to warn/prevent the routing through the empty pool.</li>
<li><strong>Execution</strong>: The user attempted to swap a high-value amount of tokens. Due to the lack of liquidity in the selected pool, the trade suffered ~100% price impact. Without a slippage revert, the transaction executed, effectively donating the funds to the pool's liquidity providers or back-running MEV bots.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/deeberiroz/status/2015763113325252857">Community Alert (deebeez)</a></li>
<li><a href="https://etherscan.io/tx/0xa4fdac0e82003fc66af56f6cefb736c95fe6d4d5a690e46a63c80b93a5b8c808">Swap Transaction (Etherscan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-11---12"><a class="header" href="#2026-01-11---12">2026-01-11 - 12</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-11 (Estimated based on report timing)</li>
<li><strong>Project</strong>: MetaverseToken (MT)</li>
<li><strong>Value Lost</strong>: ~$37,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>TenArmor detected a suspicious attack involving the MetaverseToken (MT) on BSC, resulting in a loss of approximately $37,000.</li>
<li><strong>Vulnerability</strong>: Limited details were provided, but the incident has been classified as price manipulation based on the detected on-chain behavior.</li>
<li><strong>Attack Flow</strong>: The specific mechanics involved an interaction with the MT contract that drained funds, likely via market manipulation or a flaw in how the token handles price/value calculations.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/2010630024274010460">TenArmor Alert</a></li>
<li><a href="https://bscscan.com/tx/0xc758ab15fd51e713ff8b4184620610a1ac809be06ec374305c32d3b244256a64">Attack Transaction (BscScan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-01---11"><a class="header" href="#2026-01-01---11">2026-01-01 - 11</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-01</li>
<li><strong>Project</strong>: <a href="https://x.com/valinitydefi">Valinity</a></li>
<li><strong>Value Lost</strong>: ~$63,000</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures (Flawed Rebalance Logic)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation (Spot Price Dependency)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Valinity was exploited for ~$63k due to a business logic flaw in its rebalancing mechanism.</li>
<li><strong>Vulnerability</strong>: The <code>acquireByLTVDisparity</code> function, intended to rebalance the synthetic <code>VY</code> token holdings based on LTV ratios and Uniswap V3 spot prices, was publicly callable. Crucially, the logic was flawed as it was hardcoded to execute swaps of <code>VY</code> into a liquidity pool that held negligible liquidity (~$106 USDC).</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Price Manipulation</strong>: The attacker swapped USDC for PAXG to artificially increase the PAXG price on Uniswap V3.</li>
<li><strong>Forced Dump</strong>: The attacker called the public <code>acquireByLTVDisparity</code> function. Due to the inflated PAXG price (which altered the LTV calculation), the contract logic triggered a sell-off of <code>VY</code> tokens into the illiquid pool.</li>
<li><strong>Arbitrage/Borrow</strong>: The attacker bought the dumped <code>VY</code> tokens cheaply from the pool and used them as collateral to borrow hard assets (ETH, BTC, PAXG) from the protocol, exiting with the profit.</li>
</ol>
</li>
<li><strong>Note</strong>: The protocol paused contracts following the exploit.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/2007644832815018351">TenArmor Alert</a></li>
<li><a href="https://x.com/hklst4r/status/2007366523464093850">Weilin Li Analysis</a></li>
<li><a href="https://etherscan.io/tx/0x7f1406435172b8d8675dec95a7f6aa89d10b7ca008150de8742f7fa824e3395c">Attack Transaction (Etherscan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-01---10"><a class="header" href="#2026-01-01---10">2026-01-01 - 10</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-01</li>
<li><strong>Project</strong>: PRXVTai</li>
<li><strong>Value Lost</strong>: ~$97,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures (Reward Accounting Mismatch)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.3.1: Missing Validation in Callbacks (Missing Token Transfer Hooks)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>PRXVTai was exploited for ~$97k on Base due to a flaw in its staking reward mechanics.</li>
<li><strong>Vulnerability</strong>: The <code>PRXVTStaking</code> contract minted a <strong>transferable</strong> receipt token (<code>stPRXVT</code>) representing staked <code>AgentTokenV2</code>. However, the contract failed to implement the necessary hooks (e.g., <code>_beforeTokenTransfer</code>) to update reward accounting state variables when these receipt tokens were transferred between users.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Staking/Transfer</strong>: The attacker likely staked tokens to receive <code>stPRXVT</code> or transferred <code>stPRXVT</code> between wallets.</li>
<li><strong>Accounting Desync</strong>: Because the reward logic (<code>earned()</code>) calculated rewards based on the <em>current</em> balance but the "reward debt" (or <code>userRewardPerTokenPaid</code>) was not synchronized during transfers, the system failed to correctly track how long the tokens were held by specific addresses.</li>
<li><strong>Drain</strong>: This allowed the attacker to claim inflated rewards, which were then bridged to Ethereum.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/CertiKAlert/status/2006653156927889666">CertiK Alert</a></li>
<li><a href="https://basescan.org/tx/0x88610208c00f5d5ca234e45205a01199c87cb859f881e8b35297cba8325a5494">Attack Transaction (Basescan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-20---9"><a class="header" href="#2026-01-20---9">2026-01-20 - 9</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-20</li>
<li><strong>Project</strong>: <a href="https://x.com/SynapLogic">SynapLogic</a></li>
<li><strong>Value Lost</strong>: ~$88,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.8: Faulty Array &amp; List Handling (Duplicate Entries)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>SynapLogic on Base was exploited for ~$88k due to a logic flaw in its referral system.</li>
<li><strong>Vulnerability</strong>: The <code>swapExactTokensForETHSupportingFeeOnTransferTokens</code> function accepted a user-supplied array <code>address[] refBy</code> to distribute referral rewards (10% per referee) but failed to check for duplicate addresses or cap the total payout percentage.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Duplicate Injection</strong>: The attacker called the function with the <code>refBy</code> array containing their own address repeated 31 times (e.g., <code>[self, self, ... x31]</code>).</li>
<li><strong>Reward Multiplication</strong>: The contract calculated the reward as 31 * 10% = 310% of the input value.</li>
<li><strong>Drain</strong>: The contract paid out the inflated reward in ETH/USDC from its reserves to the attacker, draining the purchasing contract.</li>
</ol>
</li>
<li><strong>Note</strong>: The attacker also minted SYP tokens during the process, but these were locked in vesting and could not be sold. The profit was derived solely from draining the contract's liquidity backing the referral payouts.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/SlowMist_Team/status/2013448818365473101">SlowMist Alert</a></li>
<li><a href="https://x.com/hklst4r/status/2013440353844461979">Weilin Li Analysis</a></li>
<li><a href="https://basescan.org/tx/0xc54c00046364b6e889db18c73beee9b81df6b5ca822b6d262b3d30cdf376c4b1">Attack Transaction (Basescan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-20---8"><a class="header" href="#2026-01-20---8">2026-01-20 - 8</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-20</li>
<li><strong>Project</strong>: <a href="https://x.com/makinafi">MakinaFi</a></li>
<li><strong>Value Lost</strong>: ~$4,130,000 (1,299 ETH)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation (Asset Inflation)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.2.2: Oracle Manipulation (Internal Accounting as Oracle)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>MakinaFi's DUSD Machine was exploited for ~$4.13M due to a vulnerability in its internal accounting logic.</li>
<li><strong>Vulnerability</strong>: The protocol used a specific <strong>Weiroll script</strong> to calculate the value of its positions (specifically in the MIM-3CRV Curve pool) to determine the Assets Under Management (AUM). This script relied on spot values that could be manipulated.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Manipulation</strong>: The attacker used large flash loans to inflate the value of the MIM-3CRV pool and the associated rewards.</li>
<li><strong>AUM Update</strong>: The attacker called <code>updateTotalAum</code>, which ran the vulnerable script. This recorded an artificially inflated value for the protocol's holdings, consequently spiking the price of the DUSD token (which is derived from AUM).</li>
<li><strong>Extraction</strong>: The attacker utilized the DUSD/USDC Curve pool (which relies on this internal price) to swap DUSD for USDC at the inflated rate.</li>
</ol>
</li>
<li><strong>Execution Twist</strong>: The original attacker (0x2F93...) deployed the exploit contract but was <strong>front-run by an MEV bot</strong> (0x935...). The MEV bot replicated the attack logic and secured the funds.</li>
<li><strong>Status</strong>: The protocol is paused (Recovery Mode). The team is negotiating with the MEV builder and a Rocket Pool validator who unintentionally received a portion of the funds to recover the assets.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.certik.com/resources/blog/makina-incident-analysis">CertiK Incident Analysis</a></li>
<li><a href="https://x.com/makinafi/status/2014079031423930710">MakinaFi Official Update</a></li>
<li><a href="https://etherscan.io/tx/0x569733b8016ef9418f0b6bde8c14224d9e759e79301499908ecbcd956a0651f5">Attack Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-21---7"><a class="header" href="#2026-01-21---7">2026-01-21 - 7</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-21</li>
<li><strong>Project</strong>: <a href="https://x.com/Sagaxyz__">SagaEVM</a> (Saga Protocol Chainlet)</li>
<li><strong>Value Lost</strong>: ~$6.8M bridged to Ethereum)</li>
<li><strong>Chain</strong>: SagaEVM / Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment (Infinite Mint)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 10.3: Cross-Protocol Interoperability Attacks (IBC Message Validation)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>SagaEVM, an EVM-compatible chainlet of the Saga Protocol, was exploited for approximately $7 million, resulting in a chain halt at block height 6593800. The exploit targeted the ecosystem's stablecoin, Saga Dollar ($D).</li>
<li><strong>Vulnerability</strong>: The flaw existed within the chain's precompile bridge contract responsible for handling Inter-Blockchain Communication (IBC). The system failed to properly validate custom payloads, allowing a malicious helper contract to bypass collateral checks and mint infinite $D tokens "out of thin air."</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Injection</strong>: The attacker deployed a malicious helper contract (0x7D69...) on SagaEVM.</li>
<li><strong>Infinite Mint</strong>: The helper contract sent crafted IBC messages to the precompile bridge, triggering the unauthorized minting of ~$7M in $D.</li>
<li><strong>Extraction</strong>: The attacker bridged the illicitly minted $D to Ethereum Mainnet via the Squid Router.</li>
<li><strong>Laundering</strong>: On Ethereum, the funds were swapped via 1inch and KyberSwap into ETH  (2,000+ ETH), USDC, yUSD, and tBTC. A portion ($800k) was deposited into Uniswap V4 liquidity positions (NFTs).</li>
</ol>
</li>
<li><strong>Status</strong>: SagaEVM remains paused. The Saga SSC mainnet and other chainlets were unaffected. The $D token depegged ~25% following the inflation event.</li>
<li><strong>Addresses</strong>:
<ul>
<li>Attacker (Saga/ETH): <code>0x2044697623AfA31459642708c83f04eCeF8C6ECB</code></li>
<li>Malicious Helper Contract (Saga): <code>0x7D69E4376535cf8c1E367418919209f70358581E</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/sagaxyz/sagaevm-security-incident-investigation-update-29a1d2a6b0cd">Official Saga Incident Update</a></li>
<li><a href="https://x.com/hklst4r/status/2014016362054639943">Analysis Tweet (Weilin Li)</a></li>
<li><a href="https://etherscan.io/address/0x2044697623afa31459642708c83f04ecef8c6ecb">Attacker Address (Etherscan)</a></li>
<li><a href="https://etherscan.io/tx/0x6aff59e800dc219ff0d1614b3dc512e7a07159197b2a6a26969a9ca25c3e33b4">Loss Transaction (Etherscan)</a></li>
<li><a href="https://x.com/PeckShieldAlert/status/2011069662377980147">QuillAudits Analysis Tweet</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-12---6"><a class="header" href="#2026-01-12---6">2026-01-12 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-12</li>
<li><strong>Project</strong>: <a href="https://x.com/yield">YO Protocol</a></li>
<li><strong>Value Lost</strong>: ~$3,710,000 (Covered by Protocol Treasury)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.3.1: Lack of Slippage Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.7: Flawed Off-Chain Infrastructure</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>YO Protocol suffered a loss of ~$3.71M during a routine rebalancing operation due to a misconfigured automated swap. The protocol's "Automated Harvesting System" attempted to swap ~$3.84M worth of stkGHO for USDC but received only ~$112k, resulting in a 97% loss.</li>
<li><strong>Vulnerability</strong>: The incident was an operational failure rather than a smart contract exploit. The vault operator (keeper bot) submitted a transaction to the Odos Router with an effectively disabled slippage parameter (set to <code>17,872,058</code>). The on-chain harvesting logic checked for "execution drift" but failed to validate the sanity of the initial output quote.</li>
<li><strong>Execution</strong>: The aggregator, following the permissive instructions, routed the massive trade through fragmented and illiquid Uniswap V4 pools (and others including Curve/Balancer). The route utilized pools with extreme fee tiers (up to 88%) and insufficient liquidity, vaporizing the funds into the hands of LPs positioned in these pools.</li>
<li><strong>Incident Response</strong>: The YO Protocol team utilized their multisig to backstop the loss, purchasing ~3.71M GHO via CoW Swap (which offers MEV protection) and redepositing it into the vault. An on-chain message was sent to the LPs requesting a return of funds in exchange for a 10% bounty.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/yo-protocols-slippage-bomb">Rekt News: Yo</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-12---5"><a class="header" href="#2026-01-12---5">2026-01-12 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-12</li>
<li><strong>Project</strong>: dHEDGE</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Patched; &gt;$10M Risk)</li>
<li><strong>Chain</strong>: Ethereum / Optimism</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.5.1: Parser Differential / Inconsistent Validation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 10.3: Cross-Protocol Interoperability Attacks</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in dHEDGEâ€™s 1inch integration guard that could have allowed a malicious pool manager to bypass slippage protection and drain over $10M in user funds.</li>
<li><strong>Vulnerability</strong>: The issue stemmed from a <strong>Parser Differential</strong> between the dHEDGE contract guard and the 1inch Router. The dHEDGE guard calculated slippage based on the <code>token</code> input parameter provided in the function call. However, the 1inch <code>unoswap</code> function for Uniswap V3 pools ignores this <code>token</code> input entirely, determining the swap direction (ZeroForOne) solely based on a specific bitmask within the <code>pool</code> uint256 identifier.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Parser Deception</strong>: A malicious manager provides a worthless "Fake Token" as the <code>token</code> input. The dHEDGE guard calculates slippage logic based on this Fake Token (which the attacker controls to ensure checks pass).</li>
<li><strong>Execution Divergence</strong>: The manager constructs the <code>pool</code> identifier such that the 1inch Router executes a swap of the <em>real</em> pool assets (e.g., USDT) -&gt; Fake Token, ignoring the <code>token</code> input provided in step 1.</li>
<li><strong>Bypass</strong>: Because the dHEDGE guard logic assumes the Fake Token is the source asset being swapped, it fails to validate the slippage/outflow of the real USDT, allowing the manager to drain the pool.</li>
</ol>
</li>
<li><strong>Incident Response</strong>: The vulnerability was disclosed by a whitehat researcher following an audit contest where it was initially missed. The protocol developers confirmed the severity and patched the issue before any exploitation occurred.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/s4muraii77/status/2012140371938070888">Vulnerability Disclosure Write-up</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-08---4"><a class="header" href="#2026-01-08---4">2026-01-08 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-08</li>
<li><strong>Project</strong>: <a href="https://x.com/TMXdex">TMXTribe</a></li>
<li><strong>Value Lost</strong>: ~$1,400,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.2: Barriers to Verification (The Specialist Gap)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>TMXTribe, a GMX fork, was exploited for approximately $1.4M over a 36-hour period due to flawed logic in its unverified contracts. The attack involved a loop of minting and staking TMX LP tokens using USDT, swapping the deposited USDT for USDG (the protocol's stablecoin), unstaking, and draining the acquired USDG.</li>
<li><strong>Vulnerability</strong>: The specific root cause was a logic bug in the LP staking and swapping mechanics that failed to account for this extraction loop. The contracts were unverified, hiding the exact flaw from independent review.</li>
<li><strong>Incident Response</strong>: Despite the exploit continuing for 36 hours, the team failed to pause the protocol. On-chain activity showed the team deploying and upgrading contracts during the attack but taking no effective action to stop the drainage.</li>
<li><strong>Addresses</strong>:
<ul>
<li>Exploiter 1: <code>0x763a67E4418278f84c04383071fC00165C112661</code></li>
<li>Exploiter 2: <code>0x16Ed3AFf3255FDDB44dAa73B4dE06f0c2E15288d</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/tmztribe-rekt">Rekt News Postmortem</a></li>
<li><a href="https://arbiscan.io/address/0x763a67e4418278f84c04383071fc00165c112661">Exploiter Address (Arbiscan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-08---3"><a class="header" href="#2026-01-08---3">2026-01-08 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-08</li>
<li><strong>Project</strong>: <a href="https://x.com/Truebitprotocol">Truebit</a></li>
<li><strong>Value Lost</strong>: ~$26,600,000</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.1: Integer Overflow &amp; Underflow</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Truebit was exploited for approximately $26.6M due to an integer overflow vulnerability. A malicious actor was able to mint tokens for 0 ETH and subsequently swap them for 8,535 ETH.</li>
<li><strong>Vulnerability</strong>: The <code>getPurchasePrice()</code> function, responsible for calculating the minting cost, relied on an internal calculation where intermediate values (<code>v9 + v12</code>) overflowed <code>2^256</code>. This overflow caused the price calculation to wrap around and result in zero (after division), allowing the attacker to mint TRU tokens for free.</li>
<li><strong>Attack Flow</strong>: The attacker called <code>AdminUpgradeabilityProxy.buyTRU()</code> to mint 240M tokens for 0 ETH, then called <code>sellTRU()</code> to drain ETH from the protocol. This process was repeated with increasing amounts.</li>
<li><strong>Addresses</strong>:
<ul>
<li>Exploiter 1: <code>0x6C8EC8f14bE7C01672d31CFa5f2CEfeAB2562b50</code></li>
<li>Exploiter 2: <code>0xc0454E545a7A715c6D3627f77bEd376a05182FBc</code></li>
<li>Protocol Contract: <code>0x764C64b2A09b09Acb100B80d8c505Aa6a0302EF2</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/CertiKAlert/status/2009627269451715005">CertiK Alert</a></li>
<li><a href="https://etherscan.io/address/0x6C8EC8f14bE7C01672d31CFa5f2CEfeAB2562b50">Exploiter 1 Address</a></li>
<li><a href="https://etherscan.io/tx/0xcd4755645595094a8ab984d0db7e3b4aabde72a5c87c4f176a030629c47fb014">Attack Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-06---2"><a class="header" href="#2026-01-06---2">2026-01-06 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-06</li>
<li><strong>Project</strong>: <a href="https://x.com/ipor_io">IPOR Fusion (USDC Optimizer on Arbitrum)</a></li>
<li><strong>Value Lost</strong>: ~$336,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 10: Network &amp; Consensus Evolution Attacks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A legacy IPOR Fusion vault (USDC on Arbitrum) was exploited for ~$336k. The exploit leveraged a "perfect storm" of a legacy vulnerability and a new attack vector introduced by EIP-7702.</li>
<li><strong>Vulnerability</strong>: The incident was caused by the combination of two factors:
<ol>
<li><strong>Legacy Logic Error</strong>: The specific legacy vault lacked strict validation for "fuses" (logic modules) in its <code>configureInstantWithdrawalFuses</code> function, trusting that only verified addresses would add them.</li>
<li><strong>EIP-7702 Delegation Hijack</strong>: An administrator account (<code>0xd8a1...</code>) had delegated its execution to a helper contract (<code>0xa3cc...</code>) via EIP-7702. This helper contract contained a vulnerability allowing arbitrary calls.</li>
</ol>
</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Identity Hijacking</strong>: The attacker exploited the arbitrary call vulnerability in the delegated helper contract to force the admin's EOA to call the Vault.</li>
<li><strong>Malicious Fuse Injection</strong>: Acting as the admin, the attacker added a malicious "fuse" to the vault.</li>
<li><strong>Drain</strong>: The attacker triggered <code>instantWithdraw</code>, causing the vault to execute the malicious fuse code and transfer assets to the attacker.</li>
</ol>
</li>
<li><strong>Incident Response</strong>: IPOR Labs acknowledged the exploit, confirmed it was isolated to this single legacy vault due to its unique configuration, and stated that the IPOR DAO would cover the shortfall from the treasury.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.ipor.io/post-mortem-ipor-usdc-optimizer-arbitrum-vault-exploit-aff11fd01b62">IPOR Official Post-Mortem</a></li>
<li><a href="https://arbiscan.io/tx/0x238b4e619158432ff5ceb279cfea38007d048af4f59901c7af2efcf32e9671b6">Malicious Fuse Injection Tx</a></li>
<li><a href="https://x.com/ipor_io/status/2008728627190321480">IPOR Security Update Tweet</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2026-01-03---1"><a class="header" href="#2026-01-03---1">2026-01-03 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2026-01-03</li>
<li><strong>Project</strong>: Flow Blockchain / deBridge / LayerZero</li>
<li><strong>Value Lost</strong>: Undetermined (Significant breakdown in cross-chain accounting; Specific transactions of ~$200k+ cited)</li>
<li><strong>Chain</strong>: Flow, Cross-chain</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary:</strong> <code>BWC 1.1.6: Unverifiable Outcomes</code> (State finality was revoked by decree, not consensus rules).</li>
<li><strong>Secondary:</strong> <code>BWC 1.1.1: Indispensable Intermediaries</code> (The validators acted as "Landlords" deciding who retains assets, failing the Walkaway Test).</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Following an undisclosed exploit, the Flow Blockchain team executed a mandatory chain rollback to revert the network state. However, the team allegedly failed to coordinate this action with critical bridge providers (e.g., deBridge, LayerZero), leading to a catastrophic state desynchronization between Flow and the broader ecosystem.</li>
<li><strong>Centralization Risk:</strong> The decision to unilaterally roll back the chain highlights the risks of centralized governance in Layer-1 blockchains, where "finality" can be revoked by the operator.</li>
<li><strong>Bridge Mismatch (Double Spend &amp; Loss):</strong> The rollback created a temporal paradox for cross-chain transactions processed during the rollback window:
<ol>
<li><strong>Bridged Out (Double Spend):</strong> Users who bridged funds <em>out</em> of Flow had their assets released on the destination chain. The rollback restored their balances on Flow to the pre-transfer state, effectively doubling their funds.</li>
<li><strong>Bridged In (Total Loss):</strong> Users who bridged funds <em>into</em> Flow had their assets locked on the source chain. The rollback erased the crediting transaction on Flow, leaving the users with no assets on either chain.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/flow_blockchain/status/2005095181755052120">Flow Blockchain Announcement</a></li>
<li><a href="https://x.com/flow_blockchain/status/2005058237272584680">deBridge/Community Alert</a></li>
</ul>
</li>
</ul>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2025-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2025-evm-contract-vulnerability-incidents-classification--analysis">2025 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2025-12-31---6"><a class="header" href="#2025-12-31---6">2025-12-31 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-29</li>
<li><strong>Project</strong>: Multiple (e.g., Skep-pe) / "Anti-Rug" Vigilante Bot</li>
<li><strong>Value Lost</strong>: Variable (Deployer ETH Locked / Failed Launches)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>Actor</strong>: <code>0x5c37ce78b79a09d211f3d35a617f980585e32b3c</code></li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.11: DoS via Front-Running (Griefing)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A sophisticated "vigilante" bot campaign was identified targeting new token launches (often categorized as "shitcoins") that utilize a specific initialization pattern.</li>
<li><strong>The Flaw:</strong> Many token contracts use a <code>startTrading</code> or <code>openTrading</code> function that unconditionally calls <code>IUniswapV2Factory.createPair()</code>. The factory reverts if a pair for the token combination already exists.</li>
<li><strong>The Exploit:</strong> The bot monitors the mempool for deployers funding their token contracts with ETH in preparation for liquidity addition. The bot then front-runs the deployer's <code>openTrading</code> transaction by calling <code>createPair</code> on the Uniswap factory directly.</li>
<li><strong>The Impact:</strong> When the deployer's transaction attempts to execute, it reverts because the pair now exists. This effectively "bricks" the launch. In many cases, the contracts lack a mechanism to rescue the ETH sent to the contract (or rely on <code>openTrading</code> to move it), causing the deployer's initial liquidity funds to be permanently locked or "burned."</li>
<li><strong>Code Snippet:</strong>
<pre><code class="language-solidity">function openTrading() external onlyOwner() {
    require(!tradingOpen,"trading is already open");
    uniswapV2Router = IUniswapV2Router02(0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D);
    _approve(address(this), address(uniswapV2Router), _tTotal);
    
    // VULNERABILITY: The bot calls factory.createPair() before this transaction executes.
    // This causes the legitimate launch transaction to revert due to the pair already existing.
    uniswapV2Pair = IUniswapV2Factory(uniswapV2Router.factory()).createPair(address(this), uniswapV2Router.WETH());
    
    uniswapV2Router.addLiquidityETH{value: address(this).balance}(address(this),balanceOf(address(this)),0,0,owner(),block.timestamp);
    IERC20(uniswapV2Pair).approve(address(uniswapV2Router), type(uint).max);
    swapEnabled = true;
    tradingOpen = true;
}
</code></pre>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/deeberiroz/status/2006295428137161113">Deeberiroz X Alert</a></li>
<li><a href="https://etherscan.io/address/0x5c37ce78b79a09d211f3d35a617f980585e32b3c">Threat Actor Address</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-12-29---5"><a class="header" href="#2025-12-29---5">2025-12-29 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-29</li>
<li><strong>Project</strong>: MSCST (Staking Contract) / GPC Token</li>
<li><strong>Value Lost</strong>: ~$129,900</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code> (Atomic Sandwich)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li><strong>Note</strong>: This incident occurred in late 2025.</li>
<li>The MSCST staking contract on BSC was exploited for ~$129.9k via an atomic sandwich attack facilitated by a public function.</li>
<li><strong>Vulnerability</strong>: The <code>releaseReward</code> function lacked access control, allowing any caller to trigger internal logic. Additionally, the function allowed the caller to specify a <code>fee</code> parameter (or implicitly used the contract's balance) to execute a swap.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Flashloan &amp; Dump</strong>: The attacker flashloaned GPC tokens and swapped them for BNB, lowering the price of GPC.</li>
<li><strong>Trigger Vulnerability</strong>: The attacker called <code>releaseReward</code> with the <code>fee</code> set to the contract's MSC balance. This function swapped MSC for GPC and transferred the GPC directly to the GPC/BNB liquidity pool (calling <code>sync</code>), effectively increasing the GPC reserves and further lowering the price (making GPC cheaper).</li>
<li><strong>Arbitrage</strong>: The attacker swapped their BNB back for GPC at the artificially lowered price, profiting from the spread, and repaid the flashloan.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/2005509505988055471">TenArmor Alert</a></li>
<li><a href="https://x.com/hklst4r/status/2005515461773885670">Weilin Li Analysis</a></li>
<li><a href="https://bscscan.com/tx/0x6c9ed4c2d81b6abfdf297b0cbc13585ed91f2a5e69e3545d3ea4316f50021b56">Attack Transaction (BscScan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-12-24---4"><a class="header" href="#2025-12-24---4">2025-12-24 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-24</li>
<li><strong>Project</strong>: EIP-7702 Delegatee Contract (Unnamed)</li>
<li><strong>Value Lost</strong>: ~$280,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 10: Network &amp; Consensus Evolution Attacks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code> (Initialization Front-Running)</li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>An uninitialized EIP-7702 delegatee contract was exploited on BSC, resulting in a loss of approximately $280,000.</li>
<li><strong>Vulnerability</strong>: The contract, intended to serve as a code source for EIP-7702 delegations, was deployed without being initialized.</li>
<li><strong>Attack Flow</strong>: The attacker called the exposed initialization function to grant themselves the owner role of the delegatee contract. Once in control of the logic contract, they were able to manipulate the accounts that had delegated to it, effectively draining the funds from the delegators.</li>
<li><strong>Aftermath</strong>: The stolen funds (~95 ETH equivalent) were subsequently deposited into Tornado Cash.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/CertiKAlert/status/2004016723264160150">CertiK Alert</a></li>
<li><a href="https://bscscan.com/tx/0x7e0d120a234b91e7d134ab3444e33a8827bab8488b4df9810d7ada866cc16649">Attack Transaction (BscScan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-12-21---3"><a class="header" href="#2025-12-21---3">2025-12-21 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-21</li>
<li><strong>Project</strong>: CHAR (Token Pair)</li>
<li><strong>Value Lost</strong>: ~$144,500</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.1.2: Back-Running</code> (MEV Skimming)</li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.7: User Disempowerment</code> (Operational Error / "Fat Finger")</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A user or project team member suffered a loss of ~$144.5k involving the CHAR token on BSC.</li>
<li><strong>Vulnerability</strong>: This was an operational error rather than a smart contract flaw. The victim mistakenly transferred CHAR tokens directly to the Uniswap V2-style liquidity pair address instead of interacting with the router to swap them.</li>
<li><strong>Execution</strong>: The liquidity pool contract's balance became greater than its tracked reserves (sync mismatch). An MEV bot detected this discrepancy and executed a transaction (likely calling <code>skim()</code> or a swap) to extract the excess tokens, effectively claiming the "donated" funds.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/2003381605763526817">TenArmor Alert</a></li>
<li><a href="https://bscscan.com/tx/0x1db1c2a9ba616659df28dff35e23051b7791e1c078fa8ccefe22a4f6c8513a7e">Attack Transaction (BscScan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-12-19---2"><a class="header" href="#2025-12-19---2">2025-12-19 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-19</li>
<li><strong>Project</strong>: Dragun69</li>
<li><strong>Value Lost</strong>: ~$87,400</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.3.3: Improper Handling of Native Tokens</code> (Missing <code>msg.value</code> Check)</li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li><strong>Note</strong>: This incident occurred in late 2025 but was logged in the 2026 database due to disclosure/reporting timing.</li>
<li>The "Dragun69: Router" contract on BSC was exploited for ~$87.4k due to a missing validation check on native token transfers.</li>
<li><strong>Vulnerability</strong>: The router's swap function (specifically for ETH -&gt; Token swaps) failed to verify <code>msg.value</code>. The contract logic assumed that the BNB amount specified in the swap parameters was provided by the caller in the current transaction. However, without the check, the contract utilized its own accumulated BNB balance to execute the swap.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Trigger</strong>: The attacker called the Aggregator Proxy, which triggered the vulnerable implementation to run a PancakeV3 swap.</li>
<li><strong>Misappropriation</strong>: The router, failing to check <code>msg.value</code>, spent its own WBNB/BNB reserves to fulfill the swap.</li>
<li><strong>Extraction</strong>: The swap callback verified the balance and forwarded the resulting tokens/BNB to a recipient address specified in the untrusted calldata (the attacker), effectively draining the contract.</li>
</ol>
</li>
<li><strong>Note</strong>: The project's deployments on Base and Ethereum were not affected as they correctly included the <code>msg.value</code> check. The BSC implementation was patched ~6 hours after the exploit.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/2002924740718067845">TenArmor Alert</a></li>
<li><a href="https://x.com/hklst4r/status/2003003168943219156">Weilin Li Analysis</a></li>
<li><a href="https://x.com/Zyy0530/status/2002984605457031573">Zyy0530 Analysis</a></li>
<li><a href="https://bscscan.com/tx/0x9f6f0b1fc0e946b58a5fa2ab14cf8c4b3630bba9abd6849bcb3c9b666f59cda7">Attack Transaction (BscScan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-12-13---1"><a class="header" href="#2025-12-13---1">2025-12-13 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-12-13</li>
<li><strong>Project</strong>: <a href="https://x.com/ribbonfinance">Ribbon Finance</a> (Legacy Contracts / Opyn Fork)</li>
<li><strong>Value Lost</strong>: ~$2,700,000</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code> (Unprotected Oracle Configuration/Ownership)</li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.2.2: Oracle Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li><strong>Note</strong>: This incident occurred in late 2025.</li>
<li>Legacy contracts associated with Ribbon Finance (specifically an Opyn fork) were exploited for approximately $2.7M.</li>
<li><strong>Vulnerability</strong>: The root cause was identified as a flawed oracle upgrade. Approximately 6 days prior to the attack, the oracle pricer was updated. This update reportedly introduced an access control vulnerability (potentially involving an unprotected <code>transferOwnership</code> or insufficient checks on the pricer whitelist logic) that allowed the attacker to manipulate price-feed proxies.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Market Creation</strong>: The attacker created a new option market (e.g., LINK/USDC) with a short expiration time.</li>
<li><strong>Oracle Manipulation</strong>: Abusing the vulnerable oracle stack, the attacker forced arbitrary expiry prices for assets like wstETH, AAVE, LINK, and WBTC into the shared Oracle at the specific expiry timestamp.</li>
<li><strong>Drain</strong>: The attacker redeemed large short oToken positions against the MarginPool. Because the MarginPool relied on the forged expiry prices for settlement, the attacker was able to drain WETH, wstETH, USDC, and WBTC.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/hklst4r/status/1999661564647882859">Weilin Li Analysis</a></li>
<li><a href="https://x.com/lzhou1110/status/1999673530661945702">LZhou Analysis</a></li>
<li><a href="https://x.com/SpecterAnalyst/status/1999532982411854109">Specter Analyst Alert</a></li>
<li><a href="https://etherscan.io/tx/0xb73e45948f4aabd77ca888710d3685dd01f1c81d24361d4ea0e4b4899d490e1e">Expiry Price Manipulation Tx (Etherscan)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-11-20---5"><a class="header" href="#2025-11-20---5">2025-11-20 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-11-20</li>
<li><strong>Project</strong>: GANA Payment</li>
<li><strong>Value Lost</strong>: ~$3,100,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 10: Network &amp; Consensus Evolution Attacks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.2.2: Private Key Leakage</code>, <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>GANA Payment, a newly launched payment protocol on BSC, was exploited for $3.1 million just nine days after launch.</li>
<li><strong>Root Cause</strong>: The exploit originated from a compromised owner private key. The attacker used this key to authorize an EIP-7702 delegation to a malicious contract.</li>
<li><strong>The Exploit</strong>: The malicious delegator contract acted as a middleman, allowing the attacker to bypass the <code>onlyEOA</code> (<code>tx.origin == msg.sender</code>) check on the staking contract. Because the transaction was an EIP-7702 transaction authorized by the owner, the staking contract perceived the calls as legitimate EOA interactions from the owner.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Access</strong>: Compromised the owner key.</li>
<li><strong>Delegation</strong>: Transferred ownership to 8 different addresses, each authorizing the malicious EIP-7702 delegator.</li>
<li><strong>Manipulation</strong>: The delegated code manipulated the <code>gana_Computility</code> reward rate to an astronomical value (10,000,000,000,000,000).</li>
<li><strong>Drain</strong>: Systematically staked and unstaked funds through these accounts, draining the protocol.</li>
</ol>
</li>
<li><strong>Aftermath</strong>: $2.1M was bridged to Ethereum, and ~$1M was laundered through Tornado Cash on BSC.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/gana-payment-rekt">Rekt.news Analysis</a></li>
<li><a href="https://bscscan.com/address/0x7A44bD9C6095Ca7b2A6f62FE65b81924c6cAb067">Malicious Delegator</a></li>
<li><a href="https://bscscan.com/tx/0x0a1fabbb536cf776335e2ded5ebf70f4c9601376e7265a127afe55305eff69ad">Exploit Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-11-11---4"><a class="header" href="#2025-11-11---4">2025-11-11 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-11-11</li>
<li><strong>Project</strong>: <a href="https://x.com/ImpermaxFinance">@ImpermaxFinance</a></li>
<li><strong>Value Lost</strong>: 380,000 $</li>
<li><strong>Chain</strong>: base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.2: Precision Loss &amp; Rounding Errors</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The exploit was a sophisticated, multi-stage attack that combined a precision loss vulnerability in the liquidation mechanism with a missing access control on a fund allocation function.</li>
<li><strong>1. Precision Loss &amp; State Manipulation:</strong> The attacker repeatedly created tiny, "underwater" debt positions in a low-liquidity lending market (cbBTC). By calling the <code>restructureBadDebt()</code> function, a rounding error allowed them to incrementally drain the market's <code>totalBalance</code> one wei at a time. This manipulation drove the pool's <code>exchangeRate</code> to near zero.</li>
<li><strong>2. Triggering a Malicious State:</strong> The attacker continued this process until the pool's <code>totalBalance</code> was exactly zero. This triggered a fallback condition in the code where the <code>exchangeRate</code> function returned a default, artificially high value of <code>1e18</code>. At this point, the attacker held nearly 100% of the pool's shares, acquired for a negligible cost.</li>
<li><strong>3. Missing Access Control &amp; Fund Drain:</strong> The attacker then exploited an unprotected <code>flashAllocate</code> function in a separate lending vault contract. This function, which lacked proper access control, was used to force the main cbBTC vault to deposit all its funds into the attacker's manipulated, malicious pool. Due to the artificially high exchange rate, the vault received almost no shares for its large deposit. The attacker, holding all the shares, then withdrew the vault's funds.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/hklst4r/status/1988339762537918895">@hklst4r X Alert</a></li>
<li><a href="https://x.com/ImpermaxFinance/status/1988636882977116667">Impermax Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-11-04---3"><a class="header" href="#2025-11-04---3">2025-11-04 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-11-04</li>
<li><strong>Project</strong>: <a href="https://x.com/MoonwellDeFi">@MoonwellDeFi</a></li>
<li><strong>Value Lost</strong>: 1,000,000 $</li>
<li><strong>Chain</strong>: base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.2.1: Insufficient Oracle Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: Moonwell DeFi's wrsETH price anomaly on November 4, 2025, stemmed from a Chainlink oracle malfunction. The protocol's vulnerability was its failure to validate the data received from its price oracle, blindly trusting an erroneously high price for wrsETH. An exploiter was able to repeatedly borrow over 20 wstETH with only ~0.02 wrstETH flashloaned and deposited due to the faulty oracle that returned a wrstETH price of <del>$5.8M. The attacker profited by approximately 295 ETH (</del>$1M).</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://basescan.org/tx/0x190a491c0ef095d5447d6d813dc8e2ec11a5710e189771c24527393a2beb05ac">Attack Tx 1 </a></li>
<li><a href="https://x.com/CertiKAlert/status/1985620452992253973">@CertiKAlertX Alert </a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-11-03---2"><a class="header" href="#2025-11-03---2">2025-11-03 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-11-03</li>
<li><strong>Project</strong>: Balancer Hack Side Story (Sonic Chain)</li>
<li><strong>Value Lost</strong>: ~$3,000,000</li>
<li><strong>Chain</strong>: Sonic</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.5.1: Parser Differential / Inconsistent Validation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 10.3: Cross-Protocol Interoperability Attacks</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>On November 3, 2025, following the Balancer V2 hack, the Sonic team attempted to contain the exploit by freezing the attacker's account on the L1 level. They set the attacker's native token balance to zero and replaced their code, intending to prevent them from paying gas to move funds.</li>
<li><strong>The Bypass (BWC 4.5.1):</strong> The attacker bypassed this "transport layer" freeze by exploiting an inconsistency between the L1 gas requirements and the application-level logic. The Beets Staked Sonic (stS) token supported ERC-2612 <code>permit</code>, which allows for gasless approvals via off-chain signatures. The attacker signed a <code>permit</code> (which requires no gas) to authorize a secondary wallet, then used that secondary wallet to <code>transferFrom</code> and drain the "frozen" assets.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://openzeppelin.com/security">OpenZeppelin Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-11-03---1"><a class="header" href="#2025-11-03---1">2025-11-03 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-11-03</li>
<li><strong>Project</strong>: Balancer V2 &amp; Forks</li>
<li><strong>Value Lost</strong>: ~$120,000,000</li>
<li><strong>Chains</strong>: Ethereum, Base, Polygon, Sonic, Arbitrum, Optimism, Berachain, Gnosis, Avalanche.</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.2: Precision Loss &amp; Rounding Errors</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.2: Permissioning &amp; Censorship Risks</code>, <code>BWC 5.1.1: Front-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li><strong>Arithmetic Vulnerability</strong>: The core of the exploit was a precision loss vulnerability within the <code>upscale</code> function in Balancer V2's Composable Stable Pools. This function would incorrectly round down when scaling factors were non-integer values. An attacker utilized the <code>batchSwap</code> feature to execute a three-stage attack: first, they precisely adjusted a token's balance to a rounding boundary; second, they performed swaps with crafted amounts, causing the rounding error to deflate the calculated price of the Balancer Pool Tokens (BPT); finally, they swapped assets back to the artificially cheapened BPT for a significant profit. This method was replicated across multiple chains where Balancer V2 or its forks were deployed.</li>
<li><strong>Censorship &amp; Centralized Interventions</strong>: Following the exploit, several chains took centralized action. Berachain validators halted the network for a hard fork; Sonic Labs froze the attacker's wallet; Gnosis froze affected pools and suspended its bridge; and Polygon validators reportedly censored the attacker's transactions.</li>
<li><strong>Front-Running</strong>: A white-hat MEV bot operator successfully front-ran some of the attacker's transactions on Ethereum, recovering and returning approximately $600,000.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://arbiscan.io/tx/0x7da32ebc615d0f29a24cacf9d18254bea3a2c730084c690ee40238b1d8b55773">Attack Tx (Arbitrum)</a></li>
<li><a href="https://x.com/Phalcon_xyz/status/1985302779263643915">X Post by @Phalcon_xyz with attack breakdown</a></li>
<li><a href="https://x.com/berachain/status/1985288599152042101">Berachain Foundation network halt tweet</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-10-15---5"><a class="header" href="#2025-10-15---5">2025-10-15 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-10-15</li>
<li><strong>Project</strong>: ZKsync OS</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Found in Audit)</li>
<li><strong>Chain</strong>: ZKsync Era</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.7: DoS via Return Data Bomb</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.1: Indispensable Intermediaries</code> (L1-&gt;L2 Queue Halt)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical denial-of-service vulnerability was identified in the ZKsync OS execution environment. The system preallocated a fixed 128 MB buffer for <code>return_data</code> from external calls.</li>
<li><strong>The Exploit</strong>: An attacker could craft a transaction that makes numerous external calls, returning large amounts of data. This would overflow the preallocated buffer (causing a panic) while remaining within the transaction's gas limit.</li>
<li><strong>Impact</strong>: Crucially, if this panic occurred within an L1-&gt;L2 transaction (which are processed sequentially in a queue), it would permanently halt the entire L1-&gt;L2 transaction queue. Since the queue processing halts on a panic, no subsequent L1-&gt;L2 transactions could ever be processed, effectively bricking the bridge.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.openzeppelin.com/zksync-os-audit-return-data-buffer">OpenZeppelin Audit Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-10-15---4"><a class="header" href="#2025-10-15---4">2025-10-15 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-10-15</li>
<li><strong>Project</strong>: ZKsync OS</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Found in Audit)</li>
<li><strong>Chain</strong>: ZKsync Era</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.4.5: Client Consensus Bug</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 7.4.2: Compiler/Architecture Correctness</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical non-determinism bug was identified in ZKsync OS during an audit. The issue stemmed from the use of architecture-dependent <code>usize</code> arithmetic in Rust.</li>
<li><strong>The Flaw</strong>: <code>usize</code> is 32-bit on the ZK prover's RISC-V architecture but 64-bit on the sequencer's x86_64 architecture.</li>
<li><strong>The Exploit Vector</strong>: An attacker could craft a transaction with calldata lengths close to <code>u32::MAX</code>.
<ul>
<li>On the <strong>Sequencer (64-bit)</strong>, the transaction processes successfully because the 64-bit integer does not overflow.</li>
<li>On the <strong>Prover (32-bit)</strong>, the same calculation overflows or panics.</li>
</ul>
</li>
<li><strong>Impact</strong>: This discrepancy effectively breaks the "Client Consensus." The sequencer accepts a block that the prover cannot prove. If such a block were committed, it would halt the L1 verification process, potentially freezing the entire ZKsync Era network.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.openzeppelin.com/zksync-os-audit-usize-arithmetic">OpenZeppelin Audit Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-10-10---3"><a class="header" href="#2025-10-10---3">2025-10-10 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-10-10</li>
<li><strong>Project</strong>: Binance</li>
<li><strong>Value Lost</strong>: Unknown</li>
<li><strong>Chain</strong>: N/A (Centralized Exchange)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.1.6: Closed-Source Design</code></li>
</ul>
</li>
<li><strong>Description</strong>: During a market crash, a trader's pair trade (one long, one short position) was liquidated in a seemingly adversarial manner. Instead of partially liquidating both positions to maintain the hedge, the exchange's closed-source liquidation engine allegedly closed the profitable short position entirely, while leaving the long position fully exposed to the market crash, leading to its complete liquidation shortly after. This highlights the risks of trading on platforms with opaque, unauditable liquidation systems that may prioritize the house's profit over optimal position resolution for the user.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/coinmamba/status/1976965643996938290">X Post by @coinmamba</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-10-10---2"><a class="header" href="#2025-10-10---2">2025-10-10 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-10-10</li>
<li><strong>Project</strong>: Multiple (Ethena Labs, Zerobase, Venus Protocol)</li>
<li><strong>Value Lost</strong>: ~$400B in total liquidations</li>
<li><strong>Chain</strong>: Not Specified</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.5.5: Geopolitically-Induced Network Stress</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.4.1: Cascade Failure from Network Congestion</code>, <code>BWC 4.2.2: Oracle Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The "Black Friday" event was a systemic failure triggered by a major geopolitical event (Trump's tariff announcement), which caused a crypto market plunge and led to a cascade of liquidations. The market crash led to mass liquidations, which in turn caused the depeg of USDe and the failure of the WBETH oracle, amplifying the crisis across multiple protocols. The Venus Protocol was directly impacted by an oracle failure when the price of WBETH depegged, highlighting the vulnerability of critical off-chain infrastructure during extreme market stress.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/GoPlusSecurity/status/1976893591772684528">X Alert by @GoPlusSecurity</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-10-04---1"><a class="header" href="#2025-10-04---1">2025-10-04 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-10-04</li>
<li><strong>Project</strong>: Abracadabra (@MIM_Spell)</li>
<li><strong>Value Lost</strong>: ~$1,700,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>: The root cause was a flawed implementation in the <code>cook</code> function, which allows users to execute multiple operations in a single transaction. The vulnerability occurred when an attacker combined two actions: <code>ACTION_BORROW</code>, which correctly set a <code>needsSolvencyCheck</code> flag to <code>true</code>, followed by <code>ACTION_CUSTOM</code>, which called an empty helper function that incorrectly returned a fresh status object, resetting the <code>needsSolvencyCheck</code> flag to <code>false</code>. This second action overwrote the critical security flag set by the first, effectively bypassing the solvency check and allowing the attacker to borrow millions in MIM tokens against zero collateral.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x842aae91c89a9e5043e64af34f53dc66daf0f033ad8afbf35ef0c93f99a9e5e6">Attack Tx</a></li>
<li><a href="https://x.com/Phalcon_xyz/status/1974533451408986417">X Alert by @Phalcon_xyz</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-30---11"><a class="header" href="#2025-09-30---11">2025-09-30 - 11</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-30</li>
<li><strong>Project</strong>: f(x) Protocol v2</li>
<li><strong>Value Lost</strong>: $0 (Funds lock-up)</li>
<li><strong>Chain</strong>: Not Specified</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.10: DoS via Forced Recursion</code></li>
</ul>
</li>
<li><strong>Description</strong>: A critical vulnerability was discovered during an audit that allowed an attacker to permanently lock user funds. The protocol used a recursive function to update user positions. An attacker could trigger around 150 insignificant liquidations, each creating a new node in a data structure. When a legitimate user later tried to manage their position, the recursive function would attempt to traverse this long chain of nodes, exceeding the EVM's call stack limit and causing the transaction to fail. This permanently prevented users from accessing their funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/news/fx-v2-audit">OpenZeppelin Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-30---10"><a class="header" href="#2025-09-30---10">2025-09-30 - 10</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-30</li>
<li><strong>Project</strong>: Uniswap v4 Hooks (Conceptual)</li>
<li><strong>Value Lost</strong>: $0 (Conceptual bug pattern)</li>
<li><strong>Chain</strong>: Not Specified</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
</ul>
</li>
<li><strong>Description</strong>: A conceptual vulnerability in donation-based penalty mechanisms, as seen in a Uniswap v4 hook designed to penalize just-in-time (JIT) liquidity. The hook donates a penalized LP's fees to other in-range LPs. The flaw allows an attacker to bypass this penalty by using a secondary account to be the sole recipient of their primary account's "donated" penalty fees, effectively turning the penalty into a self-rebate.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/news/openzeppelin-uniswap-hooks-v1.1.0-rc-2-audit#liquidity-penalty-can-be-circumvented-using-secondary-accounts">OpenZeppelin Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-27---9"><a class="header" href="#2025-09-27---9">2025-09-27 - 9</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-27</li>
<li><strong>Project</strong>: Cool</li>
<li><strong>Value Lost</strong>: $100,500</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.1: Front-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>: A proxy contract was upgraded to a new implementation named "Cool". This new implementation contained a <code>withdrawToken()</code> function that lacked proper access control. A transaction calling this unprotected function was subsequently front-run by an MEV bot, leading to the loss of all funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0xb2fe540482667d464586aeb9522887a2b3f8bf07ecd9c0873f3a7adc6fa67e04">Exploit Tx</a></li>
<li><a href="https://x.com/TenArmorAlert/status/1970015815979171983">X Alert: @TenArmorAlert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-23---8"><a class="header" href="#2025-09-23---8">2025-09-23 - 8</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-23</li>
<li><strong>Project</strong>: MYX Finance</li>
<li><strong>Value Lost</strong>: ~$73,000,000 (from liquidations)</li>
<li><strong>Chain</strong>: Not Specified</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.8: Sybil Attacks</code>, <code>BWC 1.2.3: Insider Threat</code></li>
</ul>
</li>
<li><strong>Description</strong>: A coordinated, multi-vector attack involving massive price manipulation and a large-scale Sybil attack. Attackers used 100 coordinated wallets to claim $170 million in an airdrop, securing a large supply of the token. They then generated billions in artificial volume (wash trading) and engineered a short squeeze that liquidated over $73 million from retail traders. The project's official response appeared to defend the Sybil attack, suggesting potential insider complicity.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/parabolic-mirage">Rekt News - Parabolic Mirage</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-23---7"><a class="header" href="#2025-09-23---7">2025-09-23 - 7</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-23</li>
<li><strong>Project</strong>: Base Sequencer Debate</li>
<li><strong>Value Lost</strong>: $0 (Ecosystem Risk)</li>
<li><strong>Chain</strong>: N/A (Off-Chain)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 11: Privacy &amp; Regulatory Attack Vectors</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 11.2.2: Government Overreach</code></li>
</ul>
</li>
<li><strong>Description</strong>: This incident represents a case of <strong>Regulatory Weaponization</strong>, where ecosystem participants called for regulatory action against a competitor (Base) over technical disagreements about its sequencer design. The core of the issue involved intentionally mischaracterizing a novel technology (a transaction sequencer) by equivocating it with a known regulated entity (a traditional exchange's matching engine) in an attempt to invite SEC scrutiny.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/danrobinson/status/1970557854190051463">Discussion between @danrobinson and @MaxResnick1 on X</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-13---6"><a class="header" href="#2025-09-13---6">2025-09-13 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-13</li>
<li><strong>Project</strong>: JUDAOGlobal (Tentative)</li>
<li><strong>Value Lost</strong>: $20,000,000</li>
<li><strong>Chain</strong>: Polygon</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.2: Misconfigured Proxy</code></li>
</ul>
</li>
<li><strong>Description</strong>: A developer executed a faulty proxy upgrade, setting an incorrect implementation contract for a vault holding 77 million POL tokens from a presale. Crucially, the developer forgot to call the <code>initialize</code> function on the new implementation. This failure to re-initialize the contract's state effectively wiped out all admin and upgrade privileges, leaving the contract ownerless and the $20 million in funds permanently locked and inaccessible.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://polygonscan.com/address/0x7D341e757f893e1a13D40370d0F6065ca9c4777E">Locked Contract</a></li>
<li>Flagged by: <a href="https://x.com/YannickCrypto/status/1966836235365687723">@YannickCrypto</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-12---5"><a class="header" href="#2025-09-12---5">2025-09-12 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-12</li>
<li><strong>Project</strong>: Shibarium Bridge</li>
<li><strong>Value Lost</strong>: ~$3,957,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet, Shibarium</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.2.2: Private Key Leakage</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.1: Centralization Risks</code></li>
</ul>
</li>
<li><strong>Description</strong>: A sophisticated attack compromised the Shibarium PoS bridge, resulting in the unauthorized withdrawal of multiple assets. The attacker gained control over the signing keys for 10 of the 12 network validators, allowing them to forge malicious checkpoint/exit proofs and approve fraudulent transactions. The root cause was a widespread compromise of validator keys. The incident highlighted significant centralization risks, as a majority of the validators were "internal" (operated by the core team) and their key compromise led to a catastrophic failure of the bridge's security model.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.shib.io/shibarium-bridge-security-update/">Shibarium Bridge Security Update</a></li>
<li><a href="https://etherscan.io/tx/0xe882a83afb92d6070b848ef025ae699ec043b7c2f31b21d2a08c94306f9b817e">Attack Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-10---4"><a class="header" href="#2025-09-10---4">2025-09-10 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-10</li>
<li><strong>Project</strong>: NPM Supply Chain Attack</li>
<li><strong>Value Lost</strong>: ~$50</li>
<li><strong>Chain</strong>: Multiple (ETH, BTC, SOL, TRX)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.4.4: Supply Chain Attacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.1: Social Engineering Exploits</code></li>
</ul>
</li>
<li><strong>Description</strong>: A widespread supply chain attack was identified where an attacker compromised a reputable developer's NPM account via a targeted phishing email. The attacker then injected a malicious, obfuscated payload into popular NPM packages. This payload was designed to compromise front-end applications and browser wallets by intercepting network requests and silently swapping user crypto addresses with the attacker's address during transactions.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/SlowMist_Team/status/1965236512448282713">SlowMist Team Alert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-10---3"><a class="header" href="#2025-09-10---3">2025-09-10 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-10</li>
<li><strong>Project</strong>: Reth (Ethereum Client)</li>
<li><strong>Value Lost</strong>: $0</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.4.5: Client Consensus Bug</code></li>
</ul>
</li>
<li><strong>Description</strong>: A bug in the Reth Ethereum client's state root computation caused multiple nodes running this client to stall on the Ethereum mainnet. The flaw was not in a smart contract but in the client software itself, which failed to correctly compute the state root according to the protocol rules. This led to a consensus failure where the affected nodes could not agree on the state of the chain with the rest of the network, requiring operators to manually intervene.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/gakonst/status/1962888853682798971">Announcement from Reth core developer Georgios Konstantopoulos</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-05---2"><a class="header" href="#2025-09-05---2">2025-09-05 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-05</li>
<li><strong>Project</strong>: Uniswap vs. Bancor</li>
<li><strong>Value Lost</strong>: $Millions in legal fees</li>
<li><strong>Chain</strong>: Not Applicable (Legal/Off-Chain)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 11: Privacy &amp; Regulatory Attack Vectors</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 11.2.1: Patent Trolling</code></li>
</ul>
</li>
<li><strong>Description</strong>: This incident is not a technical exploit but a legal one. The Bancor team filed a patent infringement lawsuit against Uniswap, claiming Uniswap's Automated Market Maker (AMM) violates their patent. This represents a case of <strong>Regulatory Weaponization</strong>, where the legal system is used to attack a competitor, stifle open-source innovation, and extract value, posing a systemic risk to the ecosystem.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/haydenzadams/status/1963878856391094291">@haydenzadams founder Uniswap </a></li>
<li><a href="https://x.com/danrobinson/status/1963722176458350737">@danrobinson patner Paradigm</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-09-02---1"><a class="header" href="#2025-09-02---1">2025-09-02 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-09-02</li>
<li><strong>Project</strong>: <a href="https://x.com/bunni_xyz">@bunni_xyz</a></li>
<li><strong>Value Lost</strong>: $ 8,400,000</li>
<li><strong>Chain</strong>: Ethereum, Unichain</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.2: Precision Loss &amp; Rounding Errors</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The exploit's root cause was a rounding error in the smart contract logic that updated a pool's idle balance during withdrawals. While the rounding direction was safe for single operations, it became exploitable when combined in a specific sequence.</li>
<li>The attacker used a flash loan to perform a large swap, manipulating the price and draining most of one asset from a pool. They then executed a series of 44 tiny withdrawals. Each withdrawal exploited the rounding error, causing the protocol's tracked total liquidity to decrease disproportionately more than the tiny amount actually withdrawn.</li>
<li>After corrupting the pool's internal accounting, the attacker executed a final large swap and reverse swap at the highly manipulated price, draining approximately $8.4M from the affected pools on Ethereum and Unichain.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bunni.pro/blog/09-04-2025-exploit-post-mortem">Bunni Post-Mortem Report</a></li>
<li><a href="https://x.com/bunni_xyz/status/1962766519391170988">X Announcement of Incident</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-08-25---5"><a class="header" href="#2025-08-25---5">2025-08-25 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-08-25</li>
<li><strong>Project</strong>: Panoptic</li>
<li><strong>Value Lost</strong>: $0 (White-hat rescue of over $4M)</li>
<li><strong>Chain</strong>: Ethereum, Base, Unichain</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.3.5: Insecure Cryptographic Construction</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was discovered in Panoptic's "position fingerprinting" mechanism, which allowed an attacker to bypass all solvency checks and drain funds. The flaw stemmed from a combination of an insecure cryptographic construction and insufficient input validation.</li>
<li><strong>Cryptographic Weakness</strong>: The position fingerprint was generated by XORing the <code>keccak256</code> hashes of individual position IDs. Using XOR as a combiner is cryptographically insecure, as it is vulnerable to collision attacks (e.g., via Gaussian elimination).</li>
<li><strong>Insufficient Input Validation</strong>: The protocol failed to validate that the user-supplied position IDs in a list were legitimate or even owned by the caller.</li>
<li><strong>Attack Path</strong>: An attacker could craft a fraudulent list of arbitrary, non-existent positions that produced the same XOR fingerprint as a real, high-collateral position. By submitting this spoofed list, they could trick the contract into believing they were solvent, allowing them to withdraw collateral and drain funds.</li>
<li>The vulnerability was responsibly disclosed by a researcher from Cantina, leading to a coordinated white-hat rescue operation that successfully secured over 98% of at-risk funds, preventing any loss.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://cantina.xyz/blog/panoptic-cantina-whitehat-rescue">Cantina Post-Mortem: Inside the $4M Panoptic Rescue</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-08-24---4"><a class="header" href="#2025-08-24---4">2025-08-24 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-08-24</li>
<li><strong>Project</strong>: Unverified Staking Contract</li>
<li><strong>Value Lost</strong>: ~$85,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 10: Network &amp; Consensus Evolution Attacks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>An unverified staking contract on BSC was exploited for ~$85k. The victim contract used the "EOA only" (<code>tx.origin == msg.sender</code>) check to protect its stake function from flashloan-based price manipulation.</li>
<li><strong>The Exploit</strong>: The attacker deployed a malicious contract and authorized its delegation to an EOA using a 7702-type transaction. The EOA transferred ~13.9 BNB tokens to itself, triggering arbitrary smart contract logic while ensuring that future <code>tx.origin == msg.sender</code> checks pass.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Flashloan &amp; Pump</strong>: In the fallback function, the malicious contract flashloaned $3.5M BSC-USD, bought POT tokens from the PancakeSwap BSC-USD/POT pool to inflate the price, then staked ~220k POT at the inflated price.</li>
<li><strong>Dump</strong>: The attacker swapped the remaining POT tokens back to BSC-USD tokens to repay the flashloan and almost reset the BSC-USD/POT price.</li>
<li><strong>Profit</strong>: In a subsequent transaction, the attacker unstaked and received 3.3M POT tokens (versus 220k staked) due to the inflated recorded value.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bscscan.com/address/0x0aeb8c4a449e1f712676692ef8948d8c952feb53">Unverified staking contract</a></li>
<li><a href="https://bscscan.com/tx/0x8a7c96521ac64fc33d8d8ceecdea9c1da9c72148c4399905c38a07ee47c3f36f">Exploit Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-08-24---3"><a class="header" href="#2025-08-24---3">2025-08-24 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-08-24</li>
<li><strong>Project</strong>: ShibaSwap Treasure Finder</li>
<li><strong>Value Lost</strong>: $27,000</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.1.3: Sandwich Attacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>convert()</code> function in the ShibaSwap: Treasure Finder contract lacked slippage protection, enabling exploitation through sandwich attacks. Additionally, its <code>onlyEOA()</code> modifier, intended to prevent contract calls, was bypassed using an EIP-7702 account, demonstrating a protocol upgrade-induced vulnerability.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x5c17e81b5b976cff66933bc4082ac3e9b21355a455d1864ae5f8ce6d069ea8e7">Exploit Tx 1</a></li>
<li>Flagged by: <a href="https://x.com/TenArmorAlert/status/1959805512184140043">@TenArmorAlert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-08-23---2"><a class="header" href="#2025-08-23---2">2025-08-23 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-08-23</li>
<li><strong>Project</strong>: RansomVault Hacker</li>
<li><strong>Value Lost</strong>: $90,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.1.1: Front-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>: This incident involves a hacker's (Hacker A) ransomware contract being exploited by another attacker (Hacker B), likely an MEV bot. The <code>withdrawETH</code> function was protected by a password that was passed as a cleartext argument in the transaction data. When Hacker A tried to withdraw the ransom, their transaction sat in the public mempool. Hacker B scanned the mempool, extracted the password, and submitted their own transaction with a higher gas fee to front-run Hacker A and steal the funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x0474ae70a59d34e37fc85e9910ea9b7f71dff0256d0269d2247217c38f9bca5e">Exploit Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-08-13---1"><a class="header" href="#2025-08-13---1">2025-08-13 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-08-13</li>
<li><strong>Project</strong>: Coinbase</li>
<li><strong>Value Lost</strong>: $550,000</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>: Coinbase's fee-receiver wallet lost approximately $550,000 due to mistakenly granting ERC-20 allowances to 0x's Mainnet Settler, a permissionless execution contract. This was not a hack but a configuration error that handed a sophisticated MEV bot the approval to drain dozens of token types from Coinbase's treasury, as anyone can call the Settler contract.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x4f59b88f96873486a5ae1b519bd29e16abcf0118334bad1218e300fd4e95bed4">Exploit Tx</a></li>
<li>Flagged by: <a href="https://x.com/deeberiroz/status/1955718986894549344">@deeberiroz</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-07-28---5"><a class="header" href="#2025-07-28---5">2025-07-28 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2025-07-28</li>
<li><strong>Project</strong>: SuperRare</li>
<li><strong>Value Lost</strong>: $730,000</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>: The core of the vulnerability was a logically flawed <code>require</code> statement intended to enforce access control. The code <code>require((msg.sender != owner() || msg.sender != address(0xc2...)), "Not authorized...");</code> always evaluates to true for any caller, because an address cannot be two different values simultaneously. This logical error rendered the authorization check completely ineffective, making it functionally missing.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/address/0xffb512b9176d527c5d32189c3e310ed4ab2bb9ec">Vulnerable Implementation</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-07-15---4"><a class="header" href="#2025-07-15---4">2025-07-15 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-07-15</li>
<li><strong>Project</strong>: Arcadia</li>
<li><strong>Value Lost</strong>: $3,600,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
</ul>
</li>
<li><strong>Description</strong>: The attacker exploited a missing validation vulnerability in the Asset Manager contracts. By supplying malicious calldata to a rebalancing function, the attacker tricked the Asset Manager into making an arbitrary call to a victim's Arcadia Account. Since the victim had authorized the Asset Manager, this call was successful, allowing the attacker to impersonate the Asset Manager and drain the victim's funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://arcadiafinance.notion.site/Arcadia-Post-Mortem-14-07-2025-23104482afa780fdb291cd3f41b7fc99">Postmortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-07-09---3"><a class="header" href="#2025-07-09---3">2025-07-09 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-07-09</li>
<li><strong>Project</strong>: GMX</li>
<li><strong>Value Lost</strong>: $42,000,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.1.4: Composable Reentrancy</code></li>
</ul>
</li>
<li><strong>Description</strong>: The GMX protocol was exploited via a sophisticated composable reentrancy attack. The vulnerability was in the <code>PositionManager.executeDecreaseOrder()</code> function, which made an external call (an ETH refund) to the attacker's contract. The attacker's contract then re-entered the GMX protocol, opening a large leveraged position before the initial transaction was complete. This manipulation artificially inflated the Assets Under Management (AUM) of the GLP pool, allowing the attacker to redeem their own GLP tokens at a much higher price.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://slowmist.medium.com/inside-the-gmx-hack-42-million-vanishes-in-an-instant-6e42adbdead0">Slowmist Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-07-09---2"><a class="header" href="#2025-07-09---2">2025-07-09 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-07-09</li>
<li><strong>Project</strong>: ZKSwap</li>
<li><strong>Value Lost</strong>: $5,000,000</li>
<li><strong>Chain</strong>: N/A</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.3.1: Missing Signature Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>verifyExitProof()</code> function contained a hardcoded <code>return true;</code> statement, which effectively disabled the cryptographic verification of withdrawal proofs. An attacker activated the emergency "Exodus Mode" and repeatedly called the <code>exit()</code> function with fabricated proofs, which the contract accepted due to the skipped verification, allowing the attacker to drain funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blockaid.io/blog/how-zkswaps-5m-exploit-couldve-been-prevented-with-onchain-monitoring">Postmortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-07-02---1"><a class="header" href="#2025-07-02---1">2025-07-02 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-07-02</li>
<li><strong>Project</strong>: Quickswap</li>
<li><strong>Value Lost</strong>: Unknown</li>
<li><strong>Chain</strong>: Polygon</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 10: Network &amp; Consensus Evolution Attacks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 10.4.1: EIP-7702 Delegation Risks</code></li>
</ul>
</li>
<li><strong>Description</strong>: The contract implemented an <code>onlyEOA()</code> modifier to prevent contract-based calls (like flash loans). An attacker leveraged an EIP-7702 transaction to bypass this check. EIP-7702 allows a contract to execute a call while setting the <code>msg.sender</code> to the EOA that signed the transaction. This made the <code>onlyEOA()</code> check return <code>true</code>, tricking the contract into believing the caller was a standard user while allowing the attacker to execute complex contract logic.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://polygonscan.com/address/0x44574d53474729f2949a7ecfb68b0641cfda4aa8">Vulnerable Address</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-06-20---3"><a class="header" href="#2025-06-20---3">2025-06-20 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-06-20</li>
<li><strong>Project</strong>: Unidentified Staking Contract</li>
<li><strong>Value Lost</strong>: ~$32,000</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.1: Unchecked Return Values</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.3.4: Weird ERC20 Behaviors</code></li>
</ul>
</li>
<li><strong>Description</strong>: The staking contract was exploited due to its failure to check the return value of an external call to a legacy Compound cToken (cUSDC). An attacker called the deposit function, but the underlying <code>cUSDC.transferFrom</code> call failed and returned <code>false</code> instead of reverting. The victim contract did not validate this boolean response and proceeded as if the deposit were successful, incorrectly updating the attacker's internal balance. The attacker was then able to withdraw real funds from the contract based on their unbacked, phantom deposit.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/a02b159fb438c8f0fb2a8d90bc70d8b2273d06b55920b26f637cab072b7a0e3e">Exploit Tx</a></li>
<li>Flagged by: <a href="https://x.com/deeberiroz/status/1947213692220710950">@deeberiroz</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-06-17---2"><a class="header" href="#2025-06-17---2">2025-06-17 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-06-17</li>
<li><strong>Project</strong>: MetaPool (mpETH)</li>
<li><strong>Value Lost</strong>: $227,785</li>
<li><strong>Chain</strong>: Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.7: Broken Invariant via Function Overriding</code></li>
</ul>
</li>
<li><strong>Description</strong>: The mpETH staking contract, which inherited from OpenZeppelin's <code>ERC4626Upgradeable</code>, was exploited due to a broken security invariant. The parent contract's security relied on an internal <code>_deposit</code> function to check that assets were received before minting shares. The mpETH contract overrode this internal function and moved the asset receipt check into its own public <code>deposit</code> function. However, the team failed to account for the inherited public <code>mint</code> function, which now called the new, check-less <code>_deposit</code> function, allowing an attacker to mint shares for free.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/OpenZeppelin/status/1953111764536561867">X Alert</a></li>
<li><a href="https://etherscan.io/tx/0x4f43fc6d674e85f7d306debb4a3d48e7688c2fe5a6332dd9ad57558a15c86ef9">Attack Tx (MEV Bot)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-06-02---1"><a class="header" href="#2025-06-02---1">2025-06-02 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-06-02</li>
<li><strong>Project</strong>: #FPC</li>
<li><strong>Value Lost</strong>: $4,700,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.3.2: Fee-on-Transfer &amp; Rebase Accounting Issues</code></li>
</ul>
</li>
<li><strong>Description</strong>: The protocol was exploited through a price manipulation attack that capitalized on the token's non-standard burn-on-transfer mechanism. The FPC token was designed to burn a portion of its own tokens directly from the liquidity pool during every sell transaction. An attacker used a flash loan to execute a large buy, drastically inflating the token's price, and then immediately sold the tokens. The flawed burn logic, combined with the artificially high price, allowed the attacker to drain the pool's liquidity.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bscscan.com/tx/0x3a9dd216fb6314c013fa8c4f85bfbbe0ed0a73209f54c57c1aab02ba989f5937">Attack Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-05-28---4"><a class="header" href="#2025-05-28---4">2025-05-28 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2025-05-28</li>
<li><strong>Project</strong>: Cork Protocol</li>
<li><strong>Value Lost</strong>: ~$13,200,000 (3,761 wstETH)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The protocol was drained via a highly sophisticated, two-vector exploit targeting complex interactions between its market automation and a custom Uniswap V4 hook.</li>
<li><strong>1. Price Manipulation (Setup):</strong> The attacker first exploited the market's rollover pricing logic. By executing a single trade in a low-volume period just before market expiry, they skewed the volume-weighted price calculation. This allowed them to purchase a massive number of <code>Cover Tokens</code> for a near-zero cost after the rollover completed.</li>
<li><strong>2. Arbitrary Call via Malicious Hook (Drain):</strong> The primary vulnerability was an access control flaw in Cork's hook integration. The attacker deployed their own malicious contract that also acted as a Uniswap hook. This malicious hook was able to interact with Cork's hook in a way that bypassed authorization checks, which were absent because Cork had integrated an older version of a Uniswap periphery contract before an explicit authorization feature was added upstream. This bypass allowed the attacker to illegitimately withdraw <code>Depeg Swaps</code>.</li>
<li>With both the cheaply acquired <code>Cover Tokens</code> and the stolen <code>Depeg Swaps</code>, the attacker was able to drain the Liquidity Vault of its assets.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.cork.tech/blog/post-mortem">Cork Protocol Exploit Post-Mortem</a></li>
<li><a href="https://etherscan.io/address/0x6e54115de254805365c2d9c8a2eeb9b52e54668f">Exploiter Contract 1</a></li>
<li><a href="https://etherscan.io/address/0x9af3dce0813fd7428c47f57a39da2f6dd7c9bb09">Exploiter Contract 2</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-05-23---3"><a class="header" href="#2025-05-23---3">2025-05-23 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2025-05-23</li>
<li><strong>Project</strong>: Mango Markets Exploiter Trial</li>
<li><strong>Value Lost</strong>: $0 (Legal Precedent established, related to a $110M exploit)</li>
<li><strong>Chain</strong>: N/A (Legal/Off-Chain)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 11: Privacy &amp; Regulatory Attack Vectors</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 11.2.3: "Code is Law" Defense Exploitation</code></li>
</ul>
</li>
<li><strong>Description</strong>: In a landmark ruling, U.S. District Judge Arun Subramanian vacated the fraud and manipulation convictions of Avraham Eisenberg. The judge determined that the evidence was insufficient to prove Eisenberg made "false representations" to Mango Markets, reasoning that as a decentralized, permissionless smart contract, the protocol could not be deceived. This decision validated the "code is law" defense in a US court, highlighting a critical regulatory vulnerability.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://assets.bwbx.io/documents/users/iqjWHBFdfxIU/rmmTMWKeWe9s/v0">Court Ruling Document: Case 1:23-cr-00010-AS, Document 220</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-05-18---2"><a class="header" href="#2025-05-18---2">2025-05-18 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-05-18</li>
<li><strong>Project</strong>: KRC/BUSD AMM Pool</li>
<li><strong>Value Lost</strong>: Not Specified</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.3.2: Fee-on-Transfer &amp; Rebase Accounting Issues</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The KRC/BUSD AMM pool was drained by exploiting a deflationary (fee-on-transfer) mechanism in the KRC token. The token's contract burned 9% of the transfer amount from the recipient's balance if the recipient was the AMM pool. This burn was invisible to the AMM's accounting, causing a desynchronization where the pool's actual KRC balance became lower than its tracked reserves. The attacker repeatedly triggered this burn, manipulating the internal price before executing a final swap to drain the remaining BUSD.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bscscan.com/tx/0x78f242dee5b8e15a43d23d76bce827f39eb3ac54b44edcd327c5d63de3848daf">Exploit Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-05-11---1"><a class="header" href="#2025-05-11---1">2025-05-11 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-05-11</li>
<li><strong>Project</strong>: MBU Token</li>
<li><strong>Value Lost</strong>: $2,000,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.5: Inconsistent Scaling Bugs</code></li>
</ul>
</li>
<li><strong>Description</strong>: The MBU token contract was exploited due to an inconsistent scaling bug in its <code>deposit</code> function. The contract failed to properly normalize the decimal precision of different tokens when performing calculations. This allowed an attacker to deposit a small amount of BNB and receive a vastly disproportionate number of MBU tokens in return, which were then swapped for a profit of $2 million.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bscscan.com/tx/0x2a65254b41b42f39331a0bcc9f893518d6b106e80d9a476b8ca3816325f4a150">Exploit Tx</a></li>
<li><a href="https://blog.openzeppelin.com/the-notorious-bug-digest-3">@openzeppelin Postmortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-04-24---1"><a class="header" href="#2025-04-24---1">2025-04-24 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-04-24</li>
<li><strong>Project</strong>: Zora Airdrop / 0x</li>
<li><strong>Value Lost</strong>: $128,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>: Zora's airdrop process allocated claimable $ZORA tokens to the 0x Settler contract, a permissionless contract designed to execute arbitrary transactions. An attacker exploited this by calling the Settler contract and instructing it to claim the tokens and send them to the attacker's own address. The root cause was the allocation of a claim (an unsafe approval) to a contract that was not designed to securely hold assets on its own behalf.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://basescan.org/tx/0xf71a96fe83f4c182da0c3011a0541713e966a186a5157fd37ec825a9a99deda6">Exploit Tx</a></li>
<li><a href="https://threesigma.xyz/blog/exploit/zora-airdrop-exploit-analysis">Threesigma Postmortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-03-25---2"><a class="header" href="#2025-03-25---2">2025-03-25 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-03-25</li>
<li><strong>Project</strong>: Magic Internet Money (@MIM_Spell)</li>
<li><strong>Value Lost</strong>: ~$12,900,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>: The vulnerability was in the integration between the <code>CauldronV4</code> and <code>RouterOrder</code> contracts. When an attacker's position was liquidated, the collateral held within the <code>RouterOrder</code> was correctly transferred to the liquidator. However, the <code>RouterOrder</code> contract failed to update its internal state variable (<code>inputAmount</code>) that tracked this collateral. This created an inconsistent state where the <code>Cauldron</code> contract's solvency check still considered the liquidated assets as valid collateral, allowing the attacker to borrow against this "phantom collateral."</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://arbiscan.io/tx/0x5416a5f23af22bd1c6c92dbbdb382da681884ed2be07f5c0903ab2241">Liquidate and Borrow Again Tx</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-03-05---1"><a class="header" href="#2025-03-05---1">2025-03-05 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-03-05</li>
<li><strong>Project</strong>: 1inch (Fusion V1)</li>
<li><strong>Value Lost</strong>: ~$10,000,000 (Majority returned for a bounty)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.2: Unsafe Storage &amp; Memory Handling</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 6.1: Integer Overflow &amp; Underflow</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The exploit targeted a critical calldata corruption vulnerability in the deprecated 1inch Settlement (Fusion V1) contract, which was written in low-level Yul.</li>
<li>The core of the vulnerability was an integer underflow in an assembly block that calculated a memory offset. By providing a crafted, extremely large <code>interactionLength</code> value in the order data, an attacker could cause the offset calculation to underflow.</li>
<li>This allowed the attacker to overwrite a different, controlled part of the calldata being assembled in memory. Specifically, they overwrote the legitimate <code>resolver</code> address in the order's suffix data with the victim's address (a market maker).</li>
<li>This tricked the Settlement contract into making a privileged callback to the victim's contract, triggering a function that drained the market maker's funds. The majority of funds were later returned by the attacker in exchange for a bounty.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x04975648e0db631b0620759ca934861830472678dae82b4bed493f1e1e3ed03a">Attack Tx</a></li>
<li><a href="https://blog.decurity.io/yul-calldata-corruption-1inch-postmortem-a7ea7a53bfd9">1inch Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-02-23---1"><a class="header" href="#2025-02-23---1">2025-02-23 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-02-23</li>
<li><strong>Project</strong>: <a href="https://x.com/zerolendxyz">ZeroLend</a></li>
<li><strong>Value Lost</strong>: ~$371,000 (Initial Exploit) + Undetermined ongoing extraction from new depositors</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.1.7: User Disempowerment</code> &amp; Extractive Design ("Zombie Market" / Cover-up)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li><strong>Note</strong>: This incident occurred in 2025 but was publicly exposed by Rekt.news in Jan 2026 after a 10-month cover-up.</li>
<li>ZeroLend was drained of ~$371k on this date, but the team maintained a "Zombie Market" for months, attributing withdrawal failures to "high utilization" or UI bugs while keeping the deposit function active.</li>
<li><strong>Vulnerability</strong>: The attacker utilized PT-LBTC (a Pendle Principal Token) as collateral. By manipulating the price of this illiquid derivative on the lending market, the attacker was able to borrow ~3.92 real LBTC against it, effectively draining the pool. This attack vector was identical to the Ionic Money exploit that occurred just 18 days prior (Feb 4, 2025).</li>
<li><strong>Cover-up &amp; Ongoing Extraction</strong>: ZeroLend did not disclose the loss. On-chain analysis revealed that a Gnosis Safe (created two months post-exploit) utilizing Gelato automation has been systematically withdrawing liquidity provided by new, unsuspecting depositors, effectively turning the broken protocol into a trap for users.</li>
<li><strong>Status</strong> (as of Jan 2026): The ZERO token has been delisted from major exchanges, GitHub activity has ceased, and the protocol remains largely abandoned by developers despite the frontend remaining accessible.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/zero-to-lend">Rekt News: Zero To Lend</a></li>
<li><a href="https://basescan.org/address/0x218c572b1ab6065d74bebcb708a3f523d14f7719">Attacker Address (Base)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-02-03---2"><a class="header" href="#2025-02-03---2">2025-02-03 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2025-02-03</li>
<li><strong>Project</strong>: Bybit (Centralized Exchange)</li>
<li><strong>Value Lost</strong>: ~$1,400,000,000 (401,347 ETH)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.4.4: Supply Chain Attacks (Compromised Dev Machine)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.3: Front-End Hijack/Spoofing (UI Manipulation)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Bybit suffered a massive $1.4B theft from its cold wallet due to a sophisticated supply chain attack targeting its multi-signature setup.</li>
<li><strong>Vulnerability</strong>: The attack did not exploit the smart contracts directly but rather the <strong>Safe Wallet user interface via a supply chain compromise</strong>. A developer's machine was compromised, allowing attackers to inject malicious JavaScript into the Safe UI build.</li>
<li><strong>Attack Flow</strong>:
<ol>
<li><strong>Injection</strong>: Malicious JS was injected into the Safe UI via a compromised dev machine.</li>
<li><strong>Deception</strong>: When signers attempted routine internal transfers, the script intercepted the request. It silently replaced the transaction parameters with attacker-controlled data (redirecting the proxy implementation).</li>
<li><strong>Blind Signing</strong>: The script sent the malicious payload to the hardware wallet for signing. Crucially, the signers failed to verify the raw data on the hardware device screen against the intended transaction.</li>
<li><strong>Execution</strong>: The valid signatures were used to upgrade the wallet's implementation to a malicious contract, allowing the attacker to drain 401,347 ETH.</li>
</ol>
</li>
<li><strong>Key Lesson</strong>: Multi-signature owners must verify hardware wallet prompts against the intended transaction structure (verify what you sign).</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://safe.global/secops">Safe SecOps Guidelines</a></li>
<li><a href="https://bybit.com/security/incident-report">Incident Investigation Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2025-01-13---1"><a class="header" href="#2025-01-13---1">2025-01-13 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2025-01-13</li>
<li><strong>Project</strong>: UniLend</li>
<li><strong>Value Lost</strong>: ~$197,000</li>
<li><strong>Chain</strong>: EVM</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>: The attacker exploited a critical flaw in the <code>redeemUnderlying</code> function's health factor calculation due to an incorrect order of operations. When a user redeemed assets, the contract would first burn their LP shares and <em>then</em> perform the health check. However, the check incorrectly used the contract's <em>current</em>, pre-withdrawal token balance (which was still high) against the user's <em>new</em>, post-burn share balance (which was low). This mismatch led to a massively inflated health factor calculation, allowing an undercollateralized position to appear safe and enabling the attacker to drain funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x44037ffc0993327176975e08789b71c1058318f48ddeff25890a577d6555b6ba">Attack Tx</a></li>
<li><a href="https://slowmist.medium.com/analysis-of-the-unilend-hack-90022fa35a54">SlowMist Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<p><em>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</em></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2024-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2024-evm-contract-vulnerability-incidents-classification--analysis">2024 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2024-11-10---3"><a class="header" href="#2024-11-10---3">2024-11-10 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-11-10</li>
<li><strong>Project</strong>: BGM Token</li>
<li><strong>Value Lost</strong>: Unknown (Liquidity Pool Drained)</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.8: Sybil Attacks</code>, <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The BGM token was exploited due to a flawed "transfer reward" mechanism. The protocol rewarded users for every transfer, allocating claims to the sender, recipient, and referrers, funded by the project's liquidity pool. An attacker exploited this by conducting a Sybil attack, creating numerous accounts and executing artificial transfers between them to farm rewards. After inflating their BGM holdings, the attacker withdrew the rewards and sold them into the pool, draining the USDT liquidity.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/TenArmorAlert/status/1855652562915201038">TenArmor Alert</a></li>
<li><a href="https://www.contractreader.io/contract/bsc/0x42646478b25317160e0dc8db413991277e4bb3c2#erc20-1-7-269">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-11-24---2"><a class="header" href="#2024-11-24---2">2024-11-24 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-11-24 (Disclosure Date)</li>
<li><strong>Project</strong>: Zyfy (PermissionlessPaymaster)</li>
<li><strong>Value Lost</strong>: $0 (Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: zkSync</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.2: Back-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A vulnerability was identified in Zyfy's Paymaster contract on zkSync regarding gas refund accounting.</li>
<li><strong>The Mechanism:</strong> On zkSync, unused gas is refunded to the paymaster. The contract tracked the intended recipient of this pending refund in a state variable called <code>previousManager</code>.</li>
<li><strong>The Flaw:</strong> The <code>selfRevokeSigner</code> function allowed a user to update <code>previousManager</code> immediately without checking if a refund was pending for a different manager.</li>
<li><strong>The Exploit:</strong> An attacker could back-run a transaction sponsored by a legitimate manager. By calling <code>selfRevokeSigner</code> immediately after the sponsored transaction (but before the refund logic was finalized by <code>updateRefund</code> in the next interaction), the attacker overwrote <code>previousManager</code> with their own address. Consequently, the gas refund generated by the legitimate manager's transaction was incorrectly credited to the attacker.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/cantinaxyz/status/1860745353299111979">Cantina Vulnerability Walkthrough</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-11-16---1"><a class="header" href="#2024-11-16---1">2024-11-16 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-11-16</li>
<li><strong>Project</strong>: Polter Finance</li>
<li><strong>Value Lost</strong>: ~$8,700,000</li>
<li><strong>Chain</strong>: Fantom</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.2.2: Oracle Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Polter Finance suffered a classic oracle manipulation attack due to its reliance on spot prices for asset valuation.</li>
<li><strong>The Flaw:</strong> The protocol determined the price of BOO tokens by averaging the spot prices from SpookySwap V2 and V3 pools. It lacked robust mechanisms like Time-Weighted Average Price (TWAP) or external Chainlink feeds for validation.</li>
<li><strong>The Exploit:</strong> An attacker used flash loans to massively skew the reserves in the underlying SpookySwap pools, artificially inflating the spot price of BOO. Because Polter's oracle blindly accepted this manipulated data, the system valued the attacker's small BOO deposit at an astronomical rate. This allowed the attacker to borrow effectively all assets held by the protocol against this inflated collateral.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/polter-finance-rekt/">Rekt News - Polter Finance Rekt</a></li>
<li><a href="https://certik.com/resources/blog/polter-finance-incident-analysis">CertiK Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-24---6"><a class="header" href="#2024-10-24---6">2024-10-24 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-24</li>
<li><strong>Project</strong>: Ramses Exchange</li>
<li><strong>Value Lost</strong>: ~$93,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Ramses Exchange was exploited due to multiple failures in its reward distribution logic for veNFTs.</li>
<li><strong>State Adjustment Failure:</strong> The protocol failed to decrease the <code>tokenTotalSupplyByPeriod</code> variable when rewards were claimed. This allowed the attacker to claim rewards without reducing the tracked supply, enabling repeated claims.</li>
<li><strong>Token ID Manipulation:</strong> The attacker bypassed claim limits by minting new veNFTs with new Token IDs, effectively resetting their claim status while using the same underlying capital.</li>
<li><strong>Missing Validation:</strong> The <code>getPeriodReward</code> function failed to validate that the requested reward period matched the current block timestamp, allowing the attacker to claim rewards for past periods.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.verichains.io/p/ramses-exchange-hack-analysis">Verichains Ramses Hack Analysis</a></li>
<li><a href="https://medium.com/coinmonks/unraveling-the-90k-mystery-inside-ramses-exchanges-reward-exploit-3972812b2eff">Medium Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-28---5"><a class="header" href="#2024-10-28---5">2024-10-28 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-28 (Audit Disclosure)</li>
<li><strong>Project</strong>: Royco Protocol</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum, Arbitrum, Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.8: Faulty Array &amp; List Handling</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the Royco Protocol's <code>RecipeKernel</code> during a security review.</li>
<li><strong>The Flaw:</strong> The protocol allowed Incentive Providers (IPs) to create offers with an array of reward tokens (<code>incentivesOffered</code>). However, the system failed to sanitize this array for duplicate token addresses.</li>
<li><strong>The Exploit:</strong> An attacker could create an offer where the same reward token was listed multiple times (e.g., <code>[USDC, USDC]</code>). When an Action Provider (AP) filled the offer, the contract iterated through this array to distribute rewards. Because the tracking mechanism (<code>incentiveAmountsOffered</code>) summed the total rewards correctly but the distribution loop iterated over the <em>duplicate</em> keys, the system would pay out the full reward amount for <em>each</em> occurrence of the token in the array. This resulted in the AP receiving multiples of the intended reward (e.g., double the amount if listed twice), allowing them to drain funds from the kernel.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://solodit.cyfrin.io/issues/duplicate-incentive-tokens-in-ip-offers-allow-draining-of-funds-in-recipekernel-spearbit-none-royco-pdf">Spearbit / Cantina Audit Report</a></li>
<li><a href="https://docs.royco.org/security/audits">Royco Security Review</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-31---4"><a class="header" href="#2024-10-31---4">2024-10-31 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-31 (Disclosure Date)</li>
<li><strong>Project</strong>: DeFi Wonderland (opUSDC Bridge)</li>
<li><strong>Value Lost</strong>: $0 (Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: OP Stack Chains</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.8: DoS in Cross-Chain Messaging Protocols</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 10.4: Protocol Upgrade-Induced Vulnerabilities</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical DoS vulnerability was identified in the opUSDC bridging standard, specifically regarding the migration path from "Bridged USDC" to "Native USDC."</li>
<li><strong>The Mechanism:</strong> Bridging involves locking USDC on L1 and minting it on L2. If the L2 mint fails (e.g., Out Of Gas), the message is queued and can be replayed later.</li>
<li><strong>The Flaw:</strong> The protocol allows for a "Migration" event where the L2 USDC token ownership is transferred to Circle to become native. Crucially, this revokes the Bridge Adapter's permission to mint.</li>
<li><strong>The Lock:</strong> If a user has a pending/failed L2 mint transaction <em>at the moment</em> the migration occurs, the Bridge Adapter loses its minting rights before the user can replay the transaction. The replay will permanently revert (due to missing permissions), leaving the user's funds irretrievably locked in the L1 bridge contract.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/cantinaxyz/status/1851972587561324936">Cantina Vulnerability Walkthrough</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-05---3"><a class="header" href="#2024-10-05---3">2024-10-05 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-05</li>
<li><strong>Project</strong>: AIZPT (AIZPT314)</li>
<li><strong>Value Lost</strong>: ~$20,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.4: Calculation Errors</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The AIZPT314 token contract was exploited due to a fundamental mathematical error in its custom trading logic.</li>
<li><strong>The Flaw:</strong> The protocol implemented a flawed pricing formula (<code>token0Out = token1In * token0InContract / (token1In + token1InContract)</code>) for swapping BNB for AIZPT. This implementation effectively used a quote-like or simplified formula that did not correctly account for slippage or align with the sell-side formula (which used standard Uniswap V2 logic).</li>
<li><strong>The Exploit:</strong> This discrepancy created a massive arbitrage opportunity. An attacker flashloaned BNB, bought AIZPT at the undervalued "linear" rate defined by the flawed buy formula, and then sold it back using the standard curve logic (or simply traded back and forth), extracting the contract's liquidity.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://verichains.io/news/aizpt-token-hack-analysis-by-tk-verichains">Verichains AIZPT Hack Analysis</a></li>
<li><a href="https://app.blocksec.com/explorer/tx/bsc/0x5e694707337cca979d18f9e45f40e81d6ca341ed342f1377f563e779a746460d">BlockSec Exploit Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-10---2"><a class="header" href="#2024-10-10---2">2024-10-10 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-10</li>
<li><strong>Project</strong>: HYDT</li>
<li><strong>Value Lost</strong>: ~$5,800</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.2.1: Insufficient Oracle Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The HYDT token system was exploited via a price manipulation attack on its <code>InitialMint</code> contract. The contract allowed users to mint HYDT tokens by depositing BNB, with the exchange rate determined directly by the WBNB/USDT spot price on PancakeSwap. An attacker utilized a flash loan to borrow USDT and buy a large amount of WBNB, drastically skewing the spot price. They then deposited BNB into the <code>InitialMint</code> contract at this manipulated rate to mint an inflated amount of HYDT tokens, which were subsequently sold for a profit.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://app.blocksec.com/explorer/tx/bsc/0xa9df1bd97cf6d4d1d58d3adfbdde719e46a1548db724c2e76b4cd4c3222f22b3">BlockSec Exploit Transaction</a></li>
<li><a href="https://learnblockchain.cn/article/10818">LearnBlockchain.cn Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-10-15---1"><a class="header" href="#2024-10-15---1">2024-10-15 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-10-15</li>
<li><strong>Project</strong>: Uniswap V4 Core</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Celo (and EVM chains where Native Token = ERC20)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.3.1: Double EntryPoint Tokens</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.3.3: Improper Handling of Native Tokens</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was uncovered during the audit of Uniswap V4 involving chains where the native currency also exists as an ERC-20 token (Double EntryPoint), such as CELO on Celo.</li>
<li><strong>The Mechanism:</strong> The protocol's <code>settle</code> function calculates debt (deltas) differently for native assets (using <code>msg.value</code>) and ERC-20 tokens (using <code>balanceNow - balanceBefore</code>).</li>
<li><strong>The Exploit:</strong> An attacker could exploit this dual nature by first calling <code>sync</code> to snapshot balances, then calling <code>settle</code> sending native value (increasing the delta via <code>msg.value</code>). Crucially, this action also increases the contract's ERC-20 balance. The attacker could then immediately call <code>settle</code> again using the token's ERC-20 address. The contract would interpret the previous <code>msg.value</code> deposit as a new ERC-20 transfer (since <code>balanceNow</code> &gt; <code>balanceBefore</code>), effectively crediting the user twice for the same funds.</li>
<li><strong>Impact:</strong> This accounting flaw would allow an attacker to inflate their balance artificially and drain the pool's liquidity without transferring the corresponding assets.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/uniswap-v4-core-audit#erc-20-representation-of-native-currency-can-be-used-to-drain-native-currency-pools">OpenZeppelin Uniswap V4 Core Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-25---7"><a class="header" href="#2024-09-25---7">2024-09-25 - 7</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-25 (Disclosure Date)</li>
<li><strong>Project</strong>: Fuel Network (Fuel VM)</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: Fuel</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.4.1: Incorrect VM Gas Charges</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 8.4: DoS via Numeric Calculation</code> (Resource Exhaustion)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the Fuel VM's <code>CCP</code> (Code Copy) instruction during the Fuel Attackathon.</li>
<li><strong>The Flaw:</strong> The <code>CCP</code> instruction copies code from a contract into memory but charged gas based solely on the size of the source contract's bytecode, not the actual number of bytes copied or the memory region affected. Furthermore, if the destination memory region exceeded the source bytecode size, the instruction would zero-fill the excess area.</li>
<li><strong>The Exploit:</strong> An attacker could manipulate the <code>offset</code> and <code>length</code> parameters to trigger a massive memory zero-filling operation (a resource-intensive task) while paying a negligible gas fee calculated only on the small contract size. This discrepancy allowed for "cheap" memory clearing, leading to potential network resource exhaustion and Denial of Service (DoS) attacks by underpricing computational work.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/immunefi/top-5-bugs-from-the-fuel-attackathon-313d4060824b">Immunefi: Top 5 Bugs from the Fuel Attackathon (Report 32465)</a></li>
<li><a href="https://blog.openzeppelin.com/web3-security-auditors-2024-rewind">OpenZeppelin Web3 Security Auditor's Rewind 2024</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-10---6"><a class="header" href="#2024-09-10---6">2024-09-10 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-10</li>
<li><strong>Project</strong>: Pythia Finance</li>
<li><strong>Value Lost</strong>: ~$53,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 6.4: Calculation Errors</code></li>
</ul>
</li>
<li><strong>Description</strong>: The Pythia Finance staking contract contained a critical logic error in its reward calculation. The formula calculated rewards by simply multiplying the user's current balance by an accumulating <code>rewards-per-share</code> global variable. Crucially, it failed to subtract the "debt" (rewards accumulated before the user staked), effectively acting as if the user had been staking since the protocol's inception. This allowed an attacker to deposit a large amount, immediately claim massive rewards proportional to the protocol's lifetime history, and exit.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.contractreader.io/contract/mainnet/0xe2910b29252f97bb6f3cc5e66bfa0551821c7461#abstractrewards-13-16-38">Contract Analysis</a></li>
<li><a href="https://etherscan.io/tx/0x7e19f8edb1f1666322113f15d7674593950ac94bbc25d2aff96adabdcae0a6c3">Exploit Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-03---5"><a class="header" href="#2024-09-03---5">2024-09-03 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-03</li>
<li><strong>Project</strong>: Penpie</li>
<li><strong>Value Lost</strong>: ~$27,000,000</li>
<li><strong>Chain</strong>: Ethereum, Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.1.1: Standard Reentrancy</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Penpie, a yield optimizer built on Pendle Finance, was exploited via a sophisticated reentrancy attack enabled by the permissionless registration of new markets.</li>
<li><strong>The Setup:</strong> The attacker registered a valid Pendle market but linked it to a malicious custom token (SY contract). They then triggered <code>batchHarvestMarketRewards</code>.</li>
<li><strong>The Reentrancy:</strong> This function calculated rewards by checking token balances before and after calling <code>redeemRewards</code>. During the <code>redeemRewards</code> call, the malicious token's transfer logic handed execution control back to the attacker.</li>
<li><strong>The Exploit:</strong> Inside this reentrancy window, the attacker called <code>depositMarket</code> to deposit a large amount of funds. This legitimate deposit increased the protocol's token balance. When the execution returned to the <code>harvest</code> function, it read the now-inflated "after" balance. The protocol incorrectly interpreted the difference (which included the attacker's deposit) as massive rewards earned, distributing them to the attacker.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://penpiexyz.io/blog/penpie-post-mortem-report">Penpie Post-Mortem</a></li>
<li><a href="https://medium.com/olympix/penpie-exploit-a-technical-post-mortem-analysis-8cc4d2073981">Olympix Analysis</a></li>
<li><a href="https://www.contractreader.io/contract/mainnet/0xff51c6b493c1e4df4e491865352353eadff0f9f8#pendlestakingbaseupg-56-58-298">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-26---4"><a class="header" href="#2024-09-26---4">2024-09-26 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-26</li>
<li><strong>Project</strong>: Onyx Protocol</li>
<li><strong>Value Lost</strong>: ~$3,800,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.2: Precision Loss &amp; Rounding Errors</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Onyx Protocol, a fork of Compound V2, was exploited in a repeat of the "empty market" attack.</li>
<li><strong>Precision Loss (Inflation):</strong> The protocol launched a new, low-liquidity market (VUSD) without burning initial liquidity ("dead shares"). An attacker exploited the known Compound V2 exchange rate calculation vulnerability by continuously minting and redeeming tiny amounts of shares. This process manipulated the exchange rate due to rounding errors, allowing the attacker to borrow assets worth far more than their collateral.</li>
<li><strong>Input Validation Failure:</strong> Additionally, the attacker exploited a vulnerability in Onyx's custom <code>NFTLiquidation</code> contract. The contract failed to validate input parameters during the liquidation process, allowing the attacker to use a fake token or manipulated data to self-liquidate positions and claim inflated rewards, exacerbating the loss.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/onyx-protocol-rekt2/">Rekt News - Onyx Protocol Rekt II</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-01---3"><a class="header" href="#2024-09-01---3">2024-09-01 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-01 (Incident Month)</li>
<li><strong>Project</strong>: Maia DAO</li>
<li><strong>Value Lost</strong>: $0 (Funds Rescued / ~$1.2M At Risk)</li>
<li><strong>Chain</strong>: Arbitrum, Metis (Multichain)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.7: Broken Invariant via Function Overriding</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was discovered in Maia DAO's <code>CoreBranchRouter</code> contract. The flaw stemmed from a failure to override a <code>virtual</code> function (<code>callOut</code>) in the deployed contract. The parent contract's default implementation of this function lacked the specific access controls required for the live system, as it was intended to be overridden by the child contract with proper restrictions.</li>
<li><strong>The Exploit Vector:</strong> This "missing override" oversight meant the public, unsecured parent function was exposed. It would have allowed an attacker to call the function and impersonate a trusted <code>CoreBranchRouter</code>, enabling them to bypass security checks and drain funds from the <code>CoreRootRouter</code> or brick the system.</li>
<li><strong>Outcome:</strong> The vulnerability was identified by a whitehat hacker, and the Maia DAO team successfully executed a rescue operation to secure the ~$1.2M at risk before any malicious exploitation occurred.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/@maiaDAO/post-mortem-sept-2024-05346c69b756">Maia DAO Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-23---2"><a class="header" href="#2024-09-23---2">2024-09-23 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-23</li>
<li><strong>Project</strong>: Bankroll Network</li>
<li><strong>Value Lost</strong>: ~$235,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 6.1: Integer Overflow &amp; Underflow</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>BankrollNetworkStack</code> contract was exploited due to a critical input validation failure in the <code>buyFor</code> function. The function allowed users to purchase shares on behalf of another address (<code>_customerAddress</code>) but failed to validate that this address was not the vault contract itself. An attacker exploited this by repeatedly calling <code>buyFor</code> with the vault's address as the customer, using the vault's own balance to simulate "buys". This artificially inflated the <code>profitPerShare</code> and the dividends attributed to the attacker (via the "divs" mechanism), allowing them to withdraw an inflated amount of WBNB, draining the pool.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.solidityscan.com/bankroll-network-hack-analysis-e77fd8442dfa">SolidityScan Analysis</a></li>
<li><a href="https://x.com/TenArmorAlert/status/1838183189912535492">TenArmor X Alert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-09-27---1"><a class="header" href="#2024-09-27---1">2024-09-27 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-09-27</li>
<li><strong>Project</strong>: Bedrock (uniBTC)</li>
<li><strong>Value Lost</strong>: ~$1,700,000</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.3.3: Improper Handling of Native Tokens</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.2: Faulty Contract Checks</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Bedrock protocol was exploited due to a critical flaw in how it handled native tokens on non-Bitcoin chains (e.g., ETH on Ethereum).</li>
<li><strong>The Mechanism:</strong> The system allowed minting <code>uniBTC</code> at a 1:1 ratio against BTC-equivalent assets. To prevent minting against non-equivalent assets (like ETH), the protocol set a <code>cap</code> of 0 for those assets.</li>
<li><strong>The Flaw:</strong> The <code>totalSupply</code> function, used to enforce this cap, mistakenly returned <code>0</code> for the <code>NATIVE_BTC</code> address because the native token was not properly registered in the <code>SigmaSupplier</code> contract.</li>
<li><strong>The Exploit:</strong> This logic error meant the check <code>totalSupply &lt;= cap</code> evaluated to <code>0 &lt;= 0</code> (True), bypassing the restriction. An attacker was able to deposit ETH (valued much lower than BTC) and mint <code>uniBTC</code> at a 1:1 ratio, effectively buying Bitcoin for the price of Ether and draining the protocol's liquidity.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blockapex.io/blog/bedrock-unibtc-hack-analysis/">Bedrock UniBTC Hack Analysis (BlockApex)</a></li>
<li><a href="https://github.com/Bedrock-Technology/uniBTC/blob/ed4ad7a2c27ee86038b00d9f82a3654aabcd218e/contracts/contracts/Vault.sol#L29">Vulnerable Code (GitHub)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-06---6"><a class="header" href="#2024-08-06---6">2024-08-06 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-06</li>
<li><strong>Project</strong>: Ronin Bridge</li>
<li><strong>Value Lost</strong>: ~$12,000,000 (Returned by Whitehats)</li>
<li><strong>Chain</strong>: Ethereum / Ronin</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Ronin Bridge was exploited due to a critical initialization failure during a contract upgrade.</li>
<li><strong>The Flaw:</strong> The development team upgraded the bridge proxy from version 2 to version 4 but neglected to call the intermediate <code>initializeV3</code> function. This function was responsible for initializing the <code>_totalOperatorWeight</code> variable.</li>
<li><strong>The Impact:</strong> Because the initialization was skipped, <code>_totalOperatorWeight</code> defaulted to <code>0</code>. The bridge's logic checked if the weight of provided signatures met the threshold derived from this variable. With the threshold effectively set to zero, the contract accepted empty or invalid signatures as valid authorization for withdrawals. This allowed an MEV bot (acting as a whitehat) to front-run an attack and withdraw ~$12M in ETH and USDC, effectively bypassing the bridge's multi-signature security.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.halborn.com/blog/post/explained-the-ronin-hack-august-2024">Halborn Analysis: Ronin Network Hack</a></li>
<li><a href="https://x.com/Verichains/status/1821118165218558356">Verichains Post-Mortem Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-13---5"><a class="header" href="#2024-08-13---5">2024-08-13 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-13</li>
<li><strong>Project</strong>: VOW</li>
<li><strong>Value Lost</strong>: ~$1,200,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.2: Back-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The VOW token was exploited due to a critical operational security failure involving non-atomic testing in production.</li>
<li><strong>The Flaw:</strong> The development team attempted to test a configuration change by sending a transaction to modify a critical parameter (setting the <code>usd</code> variable to the <code>vow</code> token address) with the intention of reverting it in a subsequent transaction. This created a temporal gap where the contract was live on mainnet in an invalid, vulnerable state.</li>
<li><strong>The Exploit:</strong> An attacker monitored the mempool, observed the configuration change, and back-ran the transaction. Within the window before the team could revert the change, the attacker exploited the "abnormal" stateâ€”where the system treated VOW as the stable pegâ€”to mint 100 million vUSD tokens, which were then dumped for profit.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.halborn.com/blog/post/explained-the-vow-hack-august-2024">Halborn Hack Analysis</a></li>
<li><a href="https://rekt.news/vow-rekt/">Rekt News Coverage</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-30---4"><a class="header" href="#2024-08-30---4">2024-08-30 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-30 (Audit Disclosure)</li>
<li><strong>Project</strong>: Uniswap V4 Periphery</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: EVM (Uniswap V4)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.11: DoS via Front-Running (Griefing)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.1: Front-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A Denial of Service vulnerability was identified in the Uniswap V4 Periphery contracts regarding the integration of Permit2 within multicalls.</li>
<li><strong>The Flaw:</strong> The contracts allowed users to bundle a Permit2 signature approval (<code>permit</code>) alongside other actions (like <code>addLiquidity</code> or <code>swap</code>) in a single <code>multicall</code> transaction. The code expected the <code>permit</code> call to execute successfully.</li>
<li><strong>The Exploit:</strong> An attacker could observe the pending <code>multicall</code> transaction, extract the valid Permit2 signature, and front-run the transaction by submitting the signature directly to the Permit2 contract. This consumes the signature's nonce. When the user's <code>multicall</code> transaction attempts to execute the <code>permit</code>, it reverts because the nonce has already been used. Since the <code>multicall</code> relies on all sub-calls succeeding, the entire transaction (including the intended swap or deposit) fails.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/uniswap-v4-periphery-and-universal-router-audit#dos-attack-on-multicall-via-front-running-permit-signature">OpenZeppelin Uniswap V4 Periphery Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-29---3"><a class="header" href="#2024-08-29---3">2024-08-29 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-29 (Disclosure Date)</li>
<li><strong>Project</strong>: Alchemix Finance</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.8: Faulty Array &amp; List Handling</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in Alchemix's <code>VotingEscrow</code> contract regarding how it handled historical data lookups.</li>
<li><strong>The Flaw:</strong> The protocol used a binary search algorithm to retrieve historical voting power or supply from a <code>pointHistory</code> array based on timestamps. However, the system allowed multiple checkpoints to be created with the exact same timestamp (e.g., within the same block). The binary search implementation was not designed to handle these duplicate keys; it would stop at the <em>first</em> match it found rather than the <em>latest</em> (right-most) entry.</li>
<li><strong>The Exploit:</strong> An attacker could strategically create multiple checkpoints at a specific timestamp to insert duplicate entries. By manipulating which entry the binary search returned (due to its non-deterministic handling of duplicates), the attacker could force the contract to use stale or manipulated data, potentially inflating their voting power or influencing governance outcomes.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://reports.immunefi.com/alchemix/30655-sc-critical-binary-search-does-not-correctly-handle-duplicate-timestamps.html">Immunefi Report #30655</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-30---2"><a class="header" href="#2024-08-30---2">2024-08-30 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-30 (Audit Disclosure)</li>
<li><strong>Project</strong>: Superposition AMM</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Superposition (EVM)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.3.5: EIP Standard Non-Compliance</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the <code>OwnershipNFTs.sol</code> contract during an audit.</li>
<li><strong>The Flaw:</strong> The contract implemented a custom version of the ERC-721 standard but failed to adhere to a specific requirement: clearing the <code>getApproved</code> address (token level approval) upon a token transfer.</li>
<li><strong>The Exploit:</strong> An attacker (Token Owner) could approve the NFT to a secondary address they control, sell the NFT to a victim, and thenâ€”because the approval was not revoked during the transferâ€”use the secondary address to call <code>transferFrom</code> and steal the NFT back from the buyer immediately.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/code-423n4/2024-08-superposition-findings/issues/160">Code4rena Findings Report</a></li>
<li><a href="https://github.com/code-423n4/2024-08-superposition/blob/main/pkg/sol/OwnershipNFTs.sol#L109C5-L116C6">Vulnerable Code</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-08-30---1"><a class="header" href="#2024-08-30---1">2024-08-30 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-08-30 (Audit Disclosure)</li>
<li><strong>Project</strong>: Uniswap V4 Periphery</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: EVM (Uniswap V4)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.3: Unsafe Type Casting</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A high-severity vulnerability was identified in the Uniswap V4 Periphery during an audit. The flaw existed in the <code>validateMinOut</code> function, which is responsible for enforcing slippage protection.</li>
<li><strong>The Flaw:</strong> The function performed an unsafe cast from <code>int128</code> (liquidity delta) to <code>uint128</code>. In Uniswap V4, hooks can return a negative <code>liquidityDelta</code>. When a negative value is cast directly to an unsigned integer, it underflows and wraps around to a massive positive number (e.g., casting <code>-1</code> results in <code>2^128 - 1</code>).</li>
<li><strong>The Exploit:</strong> An attacker could exploit this by interacting with a hook that returns a negative delta. The unsafe cast would incorrectly interpret this as a massive liquidity increase, bypassing the minimum output check (slippage protection) because the system would believe the user received a huge amount of assets.</li>
<li><strong>Mitigation:</strong> The issue was resolved by using <code>SafeCast.toUint128</code>, which correctly reverts if the value is negative.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/uniswap-v4-periphery-and-universal-router-audit#slippage-check-can-be-bypassed-with-unsafe-cast">OpenZeppelin Uniswap V4 Periphery Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-07-23---2"><a class="header" href="#2024-07-23---2">2024-07-23 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-07-23</li>
<li><strong>Project</strong>: Delta Prime</li>
<li><strong>Value Lost</strong>: ~$1,000,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.2.1: Unsafe Storage Use</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Delta Prime was exploited due to a critical storage collision vulnerability inherent in its proxy architecture, compounded by a forgotten initialization function.</li>
<li><strong>The Architecture:</strong> The project used a <code>DiamondBeaconProxy</code> pattern. User "Prime Accounts" were clones that delegatecalled to a <code>DiamondBeacon</code>, which then delegated to implementation facets.</li>
<li><strong>The Flaw:</strong> Both the Prime Account proxy and the Diamond contract utilized the same storage slot to store the <code>owner</code> address. However, they used <em>different</em> storage slots to track their <code>initialized</code> status. Additionally, the developers failed to remove or protect the <code>init</code> function on the DiamondBeacon after deployment.</li>
<li><strong>The Exploit:</strong> An attacker invoked the <code>init</code> function on other users' Prime Accounts. This call was delegated to the Diamond's <code>init</code> logic. Because the Diamond checked a different <code>initialized</code> storage slot (which was empty in the context of the Proxy), the check passed. The function then overwrote the <code>owner</code> storage slotâ€”which was shared by the Proxyâ€”granting the attacker full control over the victims' Prime Accounts and allowing them to drain funds.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/@Delta_Prime/deltaprime-post-mortem-report-752bd60a25e6">Delta Prime Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-07-23---4"><a class="header" href="#2024-07-23---4">2024-07-23 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-07-23</li>
<li><strong>Project</strong>: Spectra Finance</li>
<li><strong>Value Lost</strong>: ~$73,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Spectra Finance was exploited due to an arbitrary call vulnerability within its router's swap logic.</li>
<li><strong>The Flaw:</strong> The protocol allowed users to execute trades via KyberSwap, but failed to validate the <code>kyberRouter</code> address and the <code>targetData</code> payload passed to the <code>_dispatch</code> function (command type <code>0x12</code>).</li>
<li><strong>The Exploit:</strong> An attacker exploited this by passing the <code>asdCRV</code> token address as the <code>kyberRouter</code> and encoding a <code>transferFrom</code> call in the <code>targetData</code>. Since the Spectra router executed this call as itself, and users had previously approved the Spectra router to spend their <code>asdCRV</code> tokens, the attacker was able to drain funds from user wallets directly to their own.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://lunaray.medium.com/spectra-protocol-hack-analysis-06b877498757">Lunaray Hack Analysis</a></li>
<li><a href="https://verichains.io/news/spectra-protocol-exploit-arbitrary-call-strikes-again">Verichains Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-07-16---3"><a class="header" href="#2024-07-16---3">2024-07-16 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-07-16</li>
<li><strong>Project</strong>: Li.Fi (Jumper Exchange)</li>
<li><strong>Value Lost</strong>: ~$11,600,000</li>
<li><strong>Chain</strong>: Ethereum, Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Li.Fi DEX aggregator was exploited due to a critical arbitrary call vulnerability in a newly deployed facet.</li>
<li><strong>The Flaw:</strong> The protocol introduced a feature allowing users to deposit tokens and specify a route for swapping. However, the contract failed to sanitize the <code>target</code> address and <code>callData</code> provided by the user.</li>
<li><strong>The Exploit:</strong> An attacker crafted a malicious route where the <code>target</code> was a popular token contract (e.g., USDT, USDC) and the <code>callData</code> was a <code>transferFrom</code> call. Since the Li.Fi contract executed this call, and many users had granted infinite approvals to the Li.Fi contract, the attacker was able to use the protocol as a "confused deputy" to drain tokens directly from users' wallets into their own.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/lifi-jumper-rekt/">Rekt News - Li.Fi / Jumper Rekt</a></li>
<li><a href="https://x.com/lifiprotocol/status/1813165270728470945">Li.Fi Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-07-12---2"><a class="header" href="#2024-07-12---2">2024-07-12 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-07-12</li>
<li><strong>Project</strong>: Dough Finance</li>
<li><strong>Value Lost</strong>: ~$1,800,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.3.1: Missing Validation in Callbacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>ConnectorDeleverageParaswap</code> contract was exploited due to a critical validation failure in its flashloan callback execution. Users could initiate a flashloan via <code>flashloanReq</code> and provide a <code>swapData</code> parameter, intended to specify trade details for a ParaSwap interaction. This data was passed through to the <code>executeOperation</code> callback. However, the callback logic (<code>deloopAllCollaterals</code>) failed to validate or sanitize this user-supplied data. This allowed an attacker to craft malicious <code>swapData</code> that, instead of executing a swap, triggered a direct <code>WETH.transferFrom</code> call, stealing assets that users had approved to the contract.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.solidityscan.com/doughfina-hack-analysis-685ed56adb19">SolidityScan Analysis</a></li>
<li><a href="https://www.contractreader.io/contract/mainnet/0x9f54e8eAa9658316Bb8006E03FFF1cb191AafBE6#connectordeleverageparaswap-1-16-111">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-07-24---1"><a class="header" href="#2024-07-24---1">2024-07-24 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-07-24</li>
<li><strong>Project</strong>: Compound DAO</li>
<li><strong>Value Lost</strong>: $0 (Governance Takeover Averted; ~$25M Assets at Risk)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.1: DAO Governance Attacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.3.1: Social Engineering Exploits</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Compound DAO faced a hostile governance takeover attempt by a group known as the "GoldenBoyz." The attack aimed to pass Proposal 289, which sought to transfer 499k COMP tokens ($25M) from the treasury to a vault, while simultaneously delegating the voting power of those tokens to the proposers.</li>
<li><strong>Governance Exploit:</strong> Given Compound's low voter turnout (4-5%), gaining control of these tokens (5% of supply) would have allowed the attackers to unilaterally dictate future governance outcomes.</li>
<li><strong>Social Engineering &amp; Timing:</strong> The attackers used failed "test" proposals (247 and 279) to gauge community resistance. For the final malicious proposal, they employed "stealth voting," casting the majority of "for" votes at the very end of the voting window to limit the community's ability to react.</li>
<li><strong>Mitigation:</strong> The proposal passed, but the community responded with Proposal 290 to move administrative control to a Community Multisig. A truce was eventually reached, and the immediate threat to the protocol's governance was neutralized.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/compound-dao-governance-attack">OpenZeppelin Analysis</a> (Contextual Link based on description)</li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-25---1"><a class="header" href="#2024-06-25---1">2024-06-25 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-25 (Audit Disclosure)</li>
<li><strong>Project</strong>: Taiko (Bridge)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Taiko / Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.5.1: Parser Differential / Inconsistent Validation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was discovered in Taiko's bridge message processing logic during an audit, exemplifying a <strong>Parser Differential</strong> bug.</li>
<li><strong>The Mechanism:</strong> The bridge handled cross-chain messages via two distinct paths: <code>processMessage</code> (immediate execution) and <code>retryMessage</code> (delayed execution for rate-limited messages).</li>
<li><strong>The Flaw:</strong> The immediate execution path correctly validated inputs to prevent calls to forbidden addresses. However, the <code>retryMessage</code> path <strong>inconsistently applied these validations</strong>, skipping the forbidden address check entirely.</li>
<li><strong>The Exploit:</strong> An attacker could intentionally trigger the rate limit to force a malicious message into the "Retriable" state. They could then execute the message via the vulnerable <code>retryMessage</code> path, bypassing the security checks. This would allow them to execute arbitrary calls (like <code>transferFrom</code>) against forbidden targets (like token contracts) with the Bridge acting as <code>msg.sender</code>.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/taiko-protocol-audit#bridge-signals-can-be-forged-to-drain-the-protocol-phase-3">OpenZeppelin Taiko Protocol Audit</a></li>
<li><a href="https://medium.com/@nnez/different-parsers-different-results-acecf84dfb0c">Medium: Different Parsers, Different Results</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-10---5"><a class="header" href="#2024-06-10---5">2024-06-10 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-10</li>
<li><strong>Project</strong>: UWU Lend</li>
<li><strong>Value Lost</strong>: ~$19,300,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.4: Over-Leverage &amp; Liquidation Spirals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>UWU Lend was exploited due to a combination of fragile economic parameters and oracle manipulation.</li>
<li><strong>The Flaw (Over-Leverage):</strong> The protocol configured the sUSDE market with a Liquidation Threshold of 90% and a Liquidation Bonus of 10%. This left effectively zero margin for error (90% + 10% = 100%).</li>
<li><strong>The Exploit (Price Manipulation):</strong> An attacker manipulated the price of the collateral asset (sUSDE) down by just ~4% using a flash loan and curve pool imbalances. Because of the aggressive LTV parameters, this minor fluctuation allowed the attacker to liquidate their own position profitably. They could borrow assets, trigger the liquidation, and receive the 10% bonus which, combined with the manipulated price, exceeded the debt repayment cost, draining the protocol.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/@zxy211965/decoding-the-uwu-lend-exploits-minor-price-fluctuations-major-financial-losses-c9521ebe5dc9">Medium Analysis</a></li>
<li><a href="https://x.com/CertiKAlert/status/1800155208649318465">CertiK Alert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-19---4"><a class="header" href="#2024-06-19---4">2024-06-19 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-19 (Audit Disclosure)</li>
<li><strong>Project</strong>: Linea (PLONK Go Prover)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Linea (Layer 2)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.3.4: Forgetting to Blind Polynomials in ZK Protocols</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical cryptographic vulnerability was identified in Linea's PLONK Go Prover implementation during a security audit.</li>
<li><strong>The Theory:</strong> In ZK-SNARKs, provers generate polynomials to represent secret data (the witness). To prevent the verifier from reconstructing these polynomials (and thus learning the secret) via the revealed evaluations, the polynomials must be "blinded" by adding random coefficients.</li>
<li><strong>The Flaw:</strong> The Linea implementation split the quotient polynomial into "shards" but failed to apply blinding to these individual shards.</li>
<li><strong>The Impact:</strong> Without this blinding, the evaluations provided during the proof generation process leaked excessive information. This could allow an attacker to statistically reconstruct the polynomial and recover the secret witness, completely compromising the zero-knowledge property of the system.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/linea-prover-audit#the-quotient-polynomial-shards-are-not-individually-blinded">OpenZeppelin Linea Prover Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-11---3"><a class="header" href="#2024-06-11---3">2024-06-11 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-11 (Audit Disclosure)</li>
<li><strong>Project</strong>: Opal Protocol (Omnipool)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.3.1: Lack of Slippage Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.3: Sandwich Attacks</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the Opal Omnipool's reward claiming logic during a security review.</li>
<li><strong>The Flaw:</strong> When users claimed rewards, the contract executed a <code>Balancer.batchSwap</code> to convert tokens. However, the function call failed to specify a minimum output amount (limits), effectively accepting 100% slippage.</li>
<li><strong>The Exploit:</strong> An attacker could exploit this by monitoring the mempool for reward claim transactions. They could "sandwich" the transaction by front-running it to manipulate the pool's price and back-running it to capture the slippage. This would allow the attacker to siphon off a significant portion, if not all, of the user's rewards.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://solodit.cyfrin.io/issues/theft-of-rewards-via-sandwich-attack-cantina-none-opalprotocol-pdf">Cantina / Solodit Audit Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-20---2"><a class="header" href="#2024-06-20---2">2024-06-20 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-20 (Audit Disclosure)</li>
<li><strong>Project</strong>: Boost AA Wallet</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: EVM (Optimism, Base, etc.)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.3.1: Weak Random Number Generation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 1.4.1: Compromised Validator/Node</code> (Context: Validator manipulation)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the Boost AA Wallet's raffle mechanism during an audit.</li>
<li><strong>The Flaw:</strong> The protocol determined raffle winners using <code>block.prevrandao</code> and <code>block.timestamp</code> as the sole sources of randomness.</li>
<li><strong>The Exploit:</strong> While these values are hard for a regular user to predict in advance, a malicious validator (or a sequencer in L2 contexts) has control over block production. They could simulate the raffle result for a pending block and choose to withhold the block or reorganize transactions if the outcome is not favorable, effectively "re-rolling" the dice until they win.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/sherlock-audit/2024-06-boost-aa-wallet-judging/issues/11">Sherlock Findings Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-06-14---1"><a class="header" href="#2024-06-14---1">2024-06-14 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-06-14 (Public Disclosure)</li>
<li><strong>Project</strong>: Alchemix</li>
<li><strong>Value Lost</strong>: $0 (Bounty Paid: ~$28,730)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.3: Sandwich Attacks</code></li>
</ul>
</li>
<li><strong>Description</strong>: A high-severity vulnerability was identified in Alchemix's yield harvesting logic involving its integration with Gelato. The protocol intended to mitigate sandwich attacks during yield unwrapping by restricting the <code>harvest</code> functionâ€”which accepts a <code>minimumAmountOut</code> parameterâ€”to be callable only by the Gelato Automate contract. However, Alchemix integrated the generic, public Gelato Automate contract rather than a dedicated proxy. Because the generic contract allows any user to schedule tasks, an attacker could have scheduled a task instructing Gelato to call <code>harvest</code> with <code>minimumAmountOut</code> set to zero. This would satisfy the <code>msg.sender</code> check (as the call comes from Gelato) while allowing the attacker to sandwich the transaction and steal the harvested yield.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/immunefi/alchemix-access-control-issue-bugfix-review-2a8fbcddf588">Immunefi Bugfix Review</a></li>
<li><a href="https://docs.gelato.network/web3-services/web3-functions/security-considerations#dedicated-msg.sender">Gelato Security Docs</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-20---7"><a class="header" href="#2024-05-20---7">2024-05-20 - 7</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-20 (Audit Disclosure)</li>
<li><strong>Project</strong>: Elfi Protocol</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.4.2: Flawed Incentive Structures</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the Elfi Protocol's staking mechanism during a Sherlock audit.</li>
<li><strong>The Flaw:</strong> The protocol issued transferable <code>stakeToken</code> (st) as proof of deposit but calculated rewards based on the account's current <code>st</code> balance rather than an internal, non-transferable staking record.</li>
<li><strong>The Exploit:</strong> This created a "double-dipping" vulnerability. An attacker could stake tokens in Account A, transfer the <code>st</code> tokens to Account B, and claim rewards on Account B. They could then transfer the <code>st</code> tokens back to Account A (or to Account C) and claim rewards again for the same time period, effectively multiplying the yield generated by a single deposit.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/sherlock-audit/2024-05-elfi-protocol-judging/issues/146">Sherlock Audit Issue #146</a></li>
</ul>
</li>
</ul>
<h2 id="2024-05-27---6"><a class="header" href="#2024-05-27---6">2024-05-27 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-27</li>
<li><strong>Project</strong>: RedKeysGame</li>
<li><strong>Value Lost</strong>: ~$10,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.3.1: Weak Random Number Generation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>RedKeysGame</code> contract was exploited due to a Weak RNG vulnerability. The contract determined the winner of a betting game by deriving a "random" number from predictable on-chain variables, including the block's <code>timestamp</code>, <code>prevrandao</code> (difficulty), <code>gaslimit</code>, <code>coinbase</code>, and <code>number</code>. An attacker deployed a malicious contract that pre-calculated the result using these same publicly available values before submitting the bet in the same transaction block. This allowed the attacker to guarantee a win every time, draining the contract's funds.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://bscscan.com/tx/0x8d5fb97b35b830f8addcf31c8e0c6135f15bbc2163d891a3701ada0ad654d427">Exploit Transaction</a></li>
<li><a href="https://www.contractreader.io/contract/bsc/0x71e3056aa4985de9f5441f079e6c74454a3c95f0">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-16---5"><a class="header" href="#2024-05-16---5">2024-05-16 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-16</li>
<li><strong>Project</strong>: TCH Token</li>
<li><strong>Value Lost</strong>: ~$18,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 7: Low-Level &amp; EVM-Specific Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 7.3.2: Malleable ecrecover</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The TCH token contract was exploited due to a "CTF-style" signature malleability vulnerability.</li>
<li><strong>The Flaw:</strong> The <code>burnToken</code> function used <code>ecrecover</code> to validate signatures from an authorized signer. Crucially, the replay protection mechanism tracked the uniqueness of the <em>signature bytes</em> rather than the message digest or a nonce.</li>
<li><strong>The Exploit:</strong> An attacker harvested valid, previously used signatures and modified the <code>v</code> value (e.g., from <code>0x01</code> to <code>0x1c</code>). Due to the malleability of ECDSA signatures in Ethereum (where <code>s</code> and <code>-s</code> mod <code>n</code> are both valid), <code>ecrecover</code> resolved this modified signature to the same authorized signer. However, because the signature bytes were technically different, it bypassed the contract's "already used" check.</li>
<li><strong>The Impact:</strong> The attacker replayed these burn authorizations to burn a significant amount of TCH tokens held by the PancakeSwap liquidity pair. This artificially inflated the token price, allowing the attacker to sell their holdings for a profit.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://x.com/DecurityHQ/status/1791180322882629713">DecurityHQ Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-28---4"><a class="header" href="#2024-05-28---4">2024-05-28 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-28 (Audit Disclosure)</li>
<li><strong>Project</strong>: Scroll (Batch Token Bridge)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.1.2: ERC-777 Reentrancy</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code> (Related to configuration, but not the primary exploit)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical reentrancy vulnerability was identified in the Scroll Batch Token Bridge during an audit.</li>
<li><strong>The Flaw:</strong> The <code>depositERC20</code> function initiated a token transfer using <code>safeTransferFrom</code> <em>before</em> calling the internal <code>_deposit</code> function. Crucially, the <code>nonReentrant</code> modifier was placed on the internal <code>_deposit</code> function rather than the external <code>depositERC20</code> entry point.</li>
<li><strong>The Exploit:</strong> An attacker using a token with sender hooks (such as ERC-777 or compliant ERC-20s with callbacks) could re-enter the <code>depositERC20</code> function during the <code>safeTransferFrom</code> call. Because the execution flow had not yet reached the <code>_deposit</code> function where the guard resided, the reentrancy check was bypassed. This allowed the attacker to stack multiple deposits in a single transaction, potentially inflating their credited amount on L2 or locking funds in the bridge.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.openzeppelin.com/scroll-batch-token-bridge-audit#malicious-actor-can-steal-deposits-of-tokens-with-sender-hooks-or-cause-lock-of-funds">OpenZeppelin Scroll Batch Token Bridge Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-29---3"><a class="header" href="#2024-05-29---3">2024-05-29 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-29</li>
<li><strong>Project</strong>: Scroll Token (Custom Token on Scroll L2)</li>
<li><strong>Value Lost</strong>: Token Price Plunged ~99% (Amount Unknown)</li>
<li><strong>Chain</strong>: Scroll</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 6: Arithmetic &amp; Numeric Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 6.1: Integer Overflow &amp; Underflow</code></li>
</ul>
</li>
<li><strong>Description</strong>: The "Scroll Token" (a custom ERC-20 token deployed on the Scroll network, not the network's native token) was exploited due to a classic integer underflow. The developers placed a subtraction operation within an <code>unchecked</code> block to optimize gas, assuming the "from" balance was sufficient. However, the logic allowed a transfer from an address with a zero balance to underflow, wrapping around to the maximum <code>uint256</code> value. This allowed the attacker to mint a massive amount of tokens and dump them, crashing the price.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.verichains.io/p/unveiling-the-scroll-token-attack">Verichains: Unveiling the Scroll Token Attack</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-10---2"><a class="header" href="#2024-05-10---2">2024-05-10 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-10</li>
<li><strong>Project</strong>: Galaxy Fox</li>
<li><strong>Value Lost</strong>: ~$330,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>: The Galaxy Fox token contract was exploited due to a critical access control failure in its airdrop logic. The protocol used a Merkle Tree to distribute tokens, but the <code>setMerkleRoot</code> functionâ€”intended for admin use to update the eligible claim listâ€”was left public with no authorization checks. An attacker called this function to overwrite the legitimate root with a malicious one, for which they possessed a valid leaf path. This allowed them to fraudulently claim a massive amount of GFOX tokens, which they immediately swapped for ETH in the Uniswap pool.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/neptune-mutual/how-was-galaxy-fox-token-exploited-c0860520cdc2">Neptune Mutual Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-05-10---1"><a class="header" href="#2024-05-10---1">2024-05-10 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-05-10</li>
<li><strong>Project</strong>: TSURU</li>
<li><strong>Value Lost</strong>: ~$410,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.3.1: Missing Validation in Callbacks</code></li>
</ul>
</li>
<li><strong>Description</strong>: The TSURUWrapper contract was exploited due to a critical validation failure in its <code>onERC1155Received</code> hook. This function is a standard callback intended to be triggered only by the <code>TSURU</code> token contract upon a safe transfer. However, the function lacked a check to verify that <code>msg.sender</code> was the actual token contract. This allowed an attacker to call the hook directly, spoofing a deposit and minting unlimited tokens to themselves, which were then used to drain the Uniswap pool.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://neptunemutual.com/blog/analysis-of-the-tsuru-exploit/">Neptune Mutual Analysis</a></li>
<li><a href="https://x.com/shoucccc/status/1788941548929110416">X Alert by @shoucccc</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-25---1"><a class="header" href="#2024-04-25---1">2024-04-25 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-25</li>
<li><strong>Project</strong>: NGFS Token</li>
<li><strong>Value Lost</strong>: ~$190,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The NGFS token contract was exploited due to a failure to properly lock critical configuration variables upon deployment.</li>
<li><strong>The Flaw:</strong> The contract included a <code>uniswapV2Dele</code> flag intended to lock the privileged <code>_uniswapV2Proxy</code> address after initialization. However, the deployer failed to set this flag to <code>true</code> during the deployment process.</li>
<li><strong>The Exploit:</strong> Because the lock was open, an attacker was able to call the initialization function (or a setter protected by this flag) to overwrite the <code>_uniswapV2Proxy</code> with their own address. This granted them privileged access to restricted operations, allowing them to mint unlimited tokens and drain the liquidity pool.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://solidityscan.com/blog/ngfs-token-hack-analysis/">SolidityScan Hack Analysis</a></li>
<li><a href="https://www.contractreader.io/contract/bsc/0xa608985f5b40cdf6862bec775207f84280a91e3a#ngfstoken-1-11-486">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-08---9"><a class="header" href="#2024-04-08---9">2024-04-08 - 9</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-08</li>
<li><strong>Project</strong>: Squid Game (SQUID)</li>
<li><strong>Value Lost</strong>: ~$87,000</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.3.1: Lack of Slippage Control</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code>, <code>BWC 5.1.3: Sandwich Attacks</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The <code>SquidTokenSwap</code> contract was exploited due to a combination of insufficient slippage protection and missing access control on a critical function.</li>
<li><strong>The Flaw:</strong> The contract exposed a public function (<code>sellSwappedTokens</code>) that allowed any user to trigger a swap of tokens held by the contract on PancakeSwap. Crucially, this function enforced a hardcoded slippage tolerance of 5%, which is excessively wide for an automated, public function.</li>
<li><strong>The Exploit:</strong> An attacker utilized a sandwich attack strategy. They first front-ran the swap to push the price to the limit of the 5% tolerance. Then, they triggered the contract's swap function (which executed at the manipulated bad price). Finally, they back-ran the transaction to sell and capture the profit from the price movement, draining value from the protocol.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/neptune-mutual/how-was-squid-game-coin-exploited-2a8fbcddf588">Neptune Mutual Analysis</a></li>
<li><a href="https://app.blocksec.com/explorer/tx/bsc/0x9fcf38d0af4dd08f4d60f7658b623e35664e74bca0eaebdb0c3b9a6965d6257b">Exploit Transaction</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-01---8"><a class="header" href="#2024-04-01---8">2024-04-01 - 8</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04 (Incident Month)</li>
<li><strong>Project</strong>: Hackathon Token</li>
<li><strong>Value Lost</strong>: Unknown</li>
<li><strong>Chain</strong>: BSC</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.4: Self Transfers and Transaction Timing Attacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 6.4: Calculation Errors</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Hackathon token was exploited due to a flawed custom transfer logic that failed to handle self-transfers correctly, specifically when an AMM pair was both the sender and recipient.</li>
<li><strong>The Flaw:</strong> The token's transfer function contained logic intended to manage reserves but did not validate if <code>from == to</code>. When tokens were sent to the pair address, the faulty accounting logic effectively doubled the balance of the pair instead of netting it out.</li>
<li><strong>The Exploit:</strong> An attacker sent excess tokens to the Uniswap-like pair and called the <code>skim</code> function (which syncs balances to reserves) with the pair itself as the destination. The self-transfer bug doubled the "excess" tokens in the pair's balance. The attacker then called <code>skim</code> again, this time to their own address, to extract the artificially created surplus.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/SunWeb3Sec/DeFiHackLabs/blob/main/src/test/2024-04/Hackathon_exp.sol#L43C16-L48C18">DeFiHackLabs Exploit Reproduction</a></li>
<li><a href="https://www.contractreader.io/contract/bsc/0x11cee747Faaf0C0801075253ac28aB503C888888#hackathon-1-1-583">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-19---7"><a class="header" href="#2024-04-19---7">2024-04-19 - 7</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-19</li>
<li><strong>Project</strong>: Hedgey Finance</li>
<li><strong>Value Lost</strong>: ~$44,700,000</li>
<li><strong>Chain</strong>: Ethereum, Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Hedgey Finance was exploited due to a critical "lingering approval" vulnerability combined with insufficient input validation.</li>
<li><strong>The Flaw:</strong> The <code>createLockedCampaign</code> function allowed users to specify a <code>claimLockup</code> struct, which included a <code>tokenLocker</code> address. The contract would automatically approve this <code>tokenLocker</code> address to spend the campaign's tokens. Crucially, the protocol failed to validate that the <code>tokenLocker</code> was a trusted Hedgey contract. Furthermore, when a campaign was canceled, the protocol returned the funds but failed to revoke (reset to zero) the token allowance granted to the <code>tokenLocker</code>.</li>
<li><strong>The Exploit:</strong> An attacker created a campaign using a malicious contract address as the <code>tokenLocker</code>. This tricked the Hedgey contract into approving the attacker's contract to spend its funds. The attacker then canceled the campaign to retrieve their initial deposit. Because the approval was not revoked, the attacker's malicious contract retained the ability to spend funds from the Hedgey contract, which they then used to drain approximately $44.7M in assets.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.certik.com/resources/blog/hedgey-finance-incident-analysis">Hedgey Finance Incident Analysis (CertiK)</a></li>
<li><a href="https://halborn.com/explained-the-hedgey-finance-hack-april-2024/">Halborn Hack Explanation</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-30---6"><a class="header" href="#2024-04-30---6">2024-04-30 - 6</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-30 (Audit Disclosure)</li>
<li><strong>Project</strong>: Renzo Finance</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.1: DoS via External Calls</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical Denial of Service vulnerability was identified in Renzo Finance's withdrawal logic during an audit.</li>
<li><strong>The Flaw:</strong> The protocol used the legacy Solidity function <code>.transfer()</code> to send ETH to users withdrawing their assets. This function enforces a hardcoded gas limit of 2300 gas on the recipient's execution.</li>
<li><strong>The Impact:</strong> This gas stipend is insufficient for many smart contract wallets (e.g., Gnosis Safe, Argent, or wallets with complex <code>receive</code> logic) to process the incoming transaction. Consequently, legitimate withdrawals to these addresses would strictly fail with an "Out of Gas" error, effectively locking the users' funds in the contract with no way to claim them.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/code-423n4/2024-04-renzo-findings/issues/612">Code4rena Findings Report</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-16---5"><a class="header" href="#2024-04-16---5">2024-04-16 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-16 (Audit Disclosure)</li>
<li><strong>Project</strong>: Mantle Network (CrossDomainMessenger)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Mantle</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in Mantle's <code>CrossDomainMessenger</code> contract during an audit. This contract is responsible for bridging assets and relaying messages between L1 and L2.</li>
<li><strong>The Mechanism:</strong> When bridging tokens, they are minted to the <code>CrossDomainMessenger</code> on the destination chain. The messenger then calls <code>relayMessage</code> to execute the user's cross-chain intent. If a call fails, the funds remain in the messenger contract, waiting for a replay.</li>
<li><strong>The Flaw:</strong> The <code>relayMessage</code> function lacked sufficient validation of the <code>_target</code> address. It allowed the execution of arbitrary calls to any address, including the token contracts holding the bridge's assets.</li>
<li><strong>The Exploit:</strong> An attacker could craft a malicious cross-chain message targeting the MNT or ETH token contract on the destination chain. The message payload would encode a call to <code>approve(attacker, amount)</code>. Since the <code>CrossDomainMessenger</code> executes this call (making it the <code>msg.sender</code>), and it holds the locked funds, the token contract would grant the attacker approval to spend the bridge's assets. The attacker could then drain the funds using <code>transferFrom</code>.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.openzeppelin.com/mantle-v2-solidity-contracts-audit">OpenZeppelin Mantle V2 Audit</a></li>
<li><a href="https://blog.openzeppelin.com/web3-security-auditors-2024-rewind">Web3 Security Auditor's Rewind 2024</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-15---4"><a class="header" href="#2024-04-15---4">2024-04-15 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-15</li>
<li><strong>Project</strong>: SumerMoney</li>
<li><strong>Value Lost</strong>: ~$350,000</li>
<li><strong>Chain</strong>: Base</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.1.1: Standard Reentrancy</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The SumerMoney protocol (a Compound fork) was exploited due to a deviation from the standard Checks-Effects-Interactions pattern in its loan repayment logic.</li>
<li><strong>The Flaw:</strong> The <code>repayBorrow</code> function refunded excess ETH to the caller <em>before</em> updating the global <code>totalBorrows</code> state variable.</li>
<li><strong>The Exploit:</strong> An attacker repaid a loan with a 1 wei surplus. When the contract transferred this 1 wei refund, it triggered the attacker's fallback function. At this precise moment, the protocol held the repaid cash, but the <code>totalBorrows</code> figure had not yet been decreased. This temporary state inconsistency caused the exchange rate (calculated as <code>(Cash + Borrows - Reserves) / Supply</code>) to spike artificially. Inside the reentrancy hook, the attacker redeemed their collateral at this inflated rate, receiving significantly more underlying assets than they were entitled to.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://lunaray.medium.com/summermoney-hack-analysis-65257217071e">Lunaray Hack Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-16---3"><a class="header" href="#2024-04-16---3">2024-04-16 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-16 (Audit Disclosure)</li>
<li><strong>Project</strong>: Mantle Network (op-geth)</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Patched)</li>
<li><strong>Chain</strong>: Mantle</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 1: Ecosystem &amp; Off-Chain Risks</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 1.4.5: Client Consensus Bug</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 6.1: Integer Overflow &amp; Underflow</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was discovered in Mantle's execution client (<code>op-geth</code>) during an audit. The flaw was located in the state transition logic that handles L1-to-L2 ETH deposits.</li>
<li><strong>The Flaw:</strong> When processing a deposit, the Go code calculated the balance change using <code>BigInt</code> subtraction. If the "from" address had insufficient funds, the result would be a negative number. The critical failure occurred in the <code>common.BigToHash</code> function, which blindly converted this negative <code>BigInt</code> into a positive 32-byte hash (essentially underflowing/wrapping to a massive positive value) when writing to the state trie.</li>
<li><strong>Impact:</strong> This would have allowed an attacker to initiate a transfer they couldn't afford, resulting in their balance being set to a near-infinite amount instead of reverting, effectively enabling infinite ETH minting on L2.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.openzeppelin.com/mantle-op-geth-audit#attacker-can-get-infinite-bvm_eth-tokens-to-drain-the-protocol">OpenZeppelin Mantle Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-26---2"><a class="header" href="#2024-04-26---2">2024-04-26 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-26 (Audit Report Date)</li>
<li><strong>Project</strong>: Taiko (TimelockTokenPool)</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum / Taiko (Layer 2)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.3.2: Incomplete Signature Schemes</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical vulnerability was identified in the <code>TimelockTokenPool</code> contract used for Taiko grants. The contract allowed recipients to withdraw tokens using a signature authorization.</li>
<li><strong>The Flaw:</strong> The signature validation logic relied on a weak digest: <code>keccak256(abi.encodePacked("Withdraw unlocked Taiko token to: ", _to))</code>. This digest failed to include critical replay protection fields: a <strong>nonce</strong> (to prevent reusing the same signature on the same contract), the <strong>verifying contract address</strong> (to prevent reusing the signature on different pools), and the <strong>chain ID</strong> (to prevent cross-chain replays).</li>
<li><strong>The Exploit:</strong> An attacker (or a malicious recipient) could capture a valid signature used for one withdrawal and replay it multiple times to drain the pool of all unlocked tokens allocated to that grant, or potentially replay it on other chains or contract instances.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://code4rena.com/reports/2024-03-taiko#h-05-signatures-can-be-replayed-in-withdraw-to-withdraw-more-tokens-than-the-user-originally-intended">Code4rena Findings Report</a></li>
<li><a href="https://github.com/code-423n4/2024-03-taiko-findings/issues/60">GitHub Issue #60</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-04-26---1"><a class="header" href="#2024-04-26---1">2024-04-26 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-04-26</li>
<li><strong>Project</strong>: Renzo Protocol</li>
<li><strong>Value Lost</strong>: $0 (Audit Finding)</li>
<li><strong>Chain</strong>: N/A (Audit Finding)</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 8: Denial of Service (DoS) Vulnerabilities</li>
<li>Primary Classification: BWC 8.1: DoS via External Calls</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The vulnerability was caused by using a low-level <code>payable.transfer()</code> call, which forwards a fixed 2300 gas stipend, to send funds to a user withdrawing from the protocol.</li>
<li>The auditor identified that if the user's withdrawal address was a multi-sig wallet (e.g., Gnosis Safe), its fallback <code>receive()</code> function would fail due to the insufficient gas stipend.</li>
<li>This issue was critical because the withdrawal mechanism required the final claimant to be the <em>exact same address</em> that initiated the withdrawal.</li>
<li>This created a permanent DoS scenario: the Gnosis Safe could not receive the funds due to the low gas, but it was the only entity authorized to complete the withdrawal, leading to a permanent loss of funds for that user.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://github.com/code-423n4/2024-04-renzo-findings/issues/612">C423n4 Finding</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-03---2"><a class="header" href="#2024-03-03---2">2024-03-03 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-03 (Blog Series Publication)</li>
<li><strong>Project</strong>: Stargate / Drips Network</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: Omnichain (LayerZero Integrations)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.8: DoS in Cross-Chain Messaging Protocols</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 8.7: DoS via Return Data Bomb</code> (Resource Exhaustion)</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Vulnerabilities were identified in how Stargate and Drips Network integrated LayerZero, leading to permanent channel blocking.</li>
<li><strong>Stargate DoS:</strong> Stargate used a <code>try-catch</code> block to handle failed payload deliveries. Researchers found two ways to bypass this safety mechanism:
<ol>
<li><strong>EOA Target:</strong> Sending a payload to an Externally Owned Account (EOA) or a non-contract address could force the <code>try-catch</code> to revert unexpectedly without entering the catch block, blocking the nonce.</li>
<li><strong>Storage Exhaustion:</strong> Sending an extremely large payload that consumes all gas when the <code>catch</code> block attempts to store it for retry. This causes the catch block itself to revert, preventing the system from clearing the nonce.</li>
</ol>
</li>
<li><strong>Drips Network DoS:</strong> The protocol lacked a recovery mechanism for messages that indefinitely reverted at the bridge level on the destination chain. An attacker could send a message designed to always revert, permanently blocking the channel and preventing any future updates or message delivery.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.trust-security.xyz/post/learning-by-breaking-a-layerzero-case-study-part-2">Trust Security: Learning by Breaking - Part 2 (Stargate)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-03---5"><a class="header" href="#2024-03-03---5">2024-03-03 - 5</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-03 (Blog Series Publication)</li>
<li><strong>Project</strong>: LayerZero V1</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: Omnichain (LayerZero)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.8: DoS in Cross-Chain Messaging Protocols</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 8.11: DoS via Front-Running (Griefing)</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Security researchers at Trust Security disclosed multiple Denial of Service vectors in LayerZero V1.</li>
<li><strong>Nonce Overlap DoS:</strong> Messages were ordered by a nonce derived from <code>srcChain</code>, <code>srcAddress</code>, and <code>dstChain</code>, but notably excluded the <code>dstAddress</code>. An attacker could configure a malicious application to send a message using the same nonce sequence as a legitimate application on the same path. By sending a "spoofed" message that fails or hangs, the attacker could block the delivery of the legitimate application's message with the same nonce, freezing the channel.</li>
<li><strong>ONFT Gas DoS:</strong> In the ONFT (Omnichain NFT) implementation, the destination execution calls <code>onERC721Received</code>. An attacker could bridge an NFT to a malicious contract on the destination chain that consumes all available gas in this callback. This would cause the delivery transaction to revert. Because LayerZero V1 enforced strict ordering, this failed message would block all subsequent messages on that path.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.trust-security.xyz/post/learning-by-breaking-a-layerzero-case-study-part-1">Trust Security: Learning by Breaking - Part 1 (Nonce)</a></li>
<li><a href="https://www.trust-security.xyz/post/learning-by-breaking-a-layerzero-case-study-part-3">Trust Security: Learning by Breaking - Part 3 (OFT/ONFT)</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-21---4"><a class="header" href="#2024-03-21---4">2024-03-21 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-21</li>
<li><strong>Project</strong>: Super Sushi Samurai</li>
<li><strong>Value Lost</strong>: ~$4,600,000</li>
<li><strong>Chain</strong>: Blast</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.4: Self Transfers and Transaction Timing Attacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Super Sushi Samurai (SSS) token was exploited due to a critical logic error in its custom ERC-20 transfer implementation regarding self-transfers.</li>
<li><strong>The Flaw:</strong> The <code>_update</code> function handled balance updates by first subtracting the amount from the sender (<code>_balances[from] -= amount</code>) and then adding it to the recipient (<code>_balances[to] += amount</code>). However, the implementation incorrectly calculated the new recipient balance <em>before</em> updating the sender's balance in storage.</li>
<li><strong>The Exploit:</strong> When an attacker transferred tokens to themselves (<code>from == to</code>), the contract would:
<ol>
<li>Calculate <code>toBalance</code> (current balance + amount).</li>
<li>Update <code>_balances[from]</code> (current balance - amount).</li>
<li>Update <code>_balances[to]</code> with the previously calculated <code>toBalance</code>.
Since <code>from</code> and <code>to</code> are the same storage slot, step 3 overwrote the deduction from step 2, resulting in the user's balance simply increasing by the transfer amount without the corresponding decrement, effectively doubling their balance with each self-transfer.</li>
</ol>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/sss-rekt/">Rekt News - SSS Rekt</a></li>
<li><a href="https://medium.com/neptune-mutual/how-was-super-sushi-samurai-exploited-2a8fbcddf588">Neptune Mutual Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-05---3"><a class="header" href="#2024-03-05---3">2024-03-05 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-05</li>
<li><strong>Project</strong>: WOOFI</li>
<li><strong>Value Lost</strong>: ~$8,750,000</li>
<li><strong>Chain</strong>: Arbitrum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 5.2.1: Price Manipulation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.2.1: Insufficient Oracle Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The WOOFI decentralized exchange was exploited due to a vulnerability in its Synthetic Proactive Market Making (sPMM) algorithm.</li>
<li><strong>The Flaw:</strong> The sPMM pricing mechanism, which adjusted prices based on on-chain trade volume to simulate an order book, was not adequately time-weighted or capped. It allowed a single block of transactions to drastically alter the asset's price.</li>
<li><strong>The Exploit:</strong> An attacker utilized flashloans to borrow large amounts of WOO and other assets. They executed a sequence of large swaps in a low-liquidity WOO market on Arbitrum, manipulating the sPMM to value WOO at an incredibly low price ($0.00000009).</li>
<li><strong>Secondary Failure:</strong> WOOFI had a safeguard designed to fall back to a Chainlink oracle if the price deviated too far. However, this fallback was not correctly configured for the WOO token on Arbitrum. Consequently, the system accepted the manipulated price, allowing the attacker to swap back and drain the pool's WOO reserves for pennies.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://woox.io/blog/woofi-spmm-exploit-post-mortem">WOOFI Post-Mortem</a></li>
<li><a href="https://www.cyfrin.io/blog/hack-analysis-into-woofi-exploit">Cyfrin Hack Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-28---2"><a class="header" href="#2024-03-28---2">2024-03-28 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-28</li>
<li><strong>Project</strong>: Ondo Finance</li>
<li><strong>Value Lost</strong>: $0 (Audit Finding)</li>
<li><strong>Chain</strong>: N/A (Audit Finding)</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 5: Economic &amp; Game-Theoretic Vulnerabilities</li>
<li>Primary Classification: BWC 5.2.3: Hardcoded or Assumed Asset Price</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The protocol allowed users to deposit USDC to mint the native OUSG token. The amount of OUSG minted was based on a price from an OUSG/USD oracle.</li>
<li>The vulnerability was a flawed assumption in the minting calculation, which implicitly treated 1 USDC as being exactly equal to 1 USD.</li>
<li>The code used the raw <code>usdcAmountIn</code> as the basis for the USD value of the deposit, without consulting a USDC/USD oracle.</li>
<li>During a de-peg event where USDC's market price is less than $1, an attacker could acquire USDC at a discount and deposit it into the protocol. The protocol would then mint OUSG tokens as if the deposited USDC was worth its full $1 value, granting the attacker an arbitrage opportunity at the expense of the protocol.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li>Vulnerable Contract Code:
<pre><code class="language-javascript">function _getMintAmount(
    uint256 usdcAmountIn,
    uint256 price
) internal view returns (uint256 ousgAmountOut) {
    uint256 amountE36 = usdcAmountIn * 1e18;
    ousgAmountOut = amountE36 / price;
}
</code></pre>
</li>
<li><a href="https://github.com/code-423n4/2024-03-ondo-finance-findings/issues/278">C423n4 Finding</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-03-28---1"><a class="header" href="#2024-03-28---1">2024-03-28 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-03-28</li>
<li><strong>Project</strong>: Prisma Finance</li>
<li><strong>Value Lost</strong>: ~$12,000,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.3.1: Missing Validation in Callbacks</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: The <code>MigrateTroveZap</code> contract was exploited due to a critical validation failure in its <code>onFlashLoan</code> callback function. This function was intended to be called only by the lending protocol as part of a legitimate flashloan-initiated migration process. However, the function failed to verify the context of the call or the input data source. This allowed an attacker to invoke <code>onFlashLoan</code> directly with maliciously crafted data, instructing the contract to close other users' "Troves" (collateralized debt positions) and move their collateral. The attacker then manipulated the resulting position to withdraw the excess collateral for themselves.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://hackmd.io/@PrismaRisk/PostMortem0328">Prisma Finance Post-Mortem</a></li>
<li><a href="https://www.contractreader.io/contract/mainnet/0xcc7218100da61441905e0c327749972e3cbee9ee#migratetrovezap-1-10-62">Contract Analysis</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-02-05---1"><a class="header" href="#2024-02-05---1">2024-02-05 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-02-05</li>
<li><strong>Project</strong>: Wrapped XETA (WXETA)</li>
<li><strong>Value Lost</strong>: ~$25,000 (Liquidity Pool Drained)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.1: Improper Initialization</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.1.1: Missing Access Control</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Wrapped XETA (WXETA) contract was exploited due to a critical re-initialization vulnerability.</li>
<li><strong>The Flaw:</strong> The contract's <code>initialize</code> function failed to properly set the <code>initialized</code> state variable (or check it correctly), leaving the contract open to being initialized again.</li>
<li><strong>The Exploit:</strong> An attacker called the public <code>initialize</code> function on the already-deployed contract. This allowed them to overwrite the contract's owner/admin role with their own address. Once they gained admin privileges, they granted themselves minting permissions, minted a massive supply of WXETA tokens, and dumped them into the USDT/WXETA Uniswap pool to drain its liquidity.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.contractreader.io/contract/mainnet/0x3802a712d24eabcfd825fc4dd508abc01e75753e#wxeta-1-1-56">Contract Analysis</a></li>
<li><a href="https://x.com/CertiKAlert/status/1754422201213038933">CertiK Alert</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-01-22---4"><a class="header" href="#2024-01-22---4">2024-01-22 - 4</a></h2>
<ul>
<li><strong>Date</strong>: 2024-01-22 (Audit Disclosure)</li>
<li><strong>Project</strong>: Restake Finance</li>
<li><strong>Value Lost</strong>: $0 (Critical Audit Finding)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 3: Smart Contract Logic &amp; State Manipulation</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 3.2.5: Broken State Adjustment</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 7.2: Unsafe Storage &amp; Memory Handling</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A critical logic error was identified in Restake Finance's withdrawal mechanism during an audit.</li>
<li><strong>The Flaw:</strong> The protocol processed withdrawals by sending the underlying assets to the user, deleting the <code>WithdrawalRequest</code> struct from storage, and <em>then</em> attempting to burn the corresponding shares.</li>
<li><strong>The Exploit:</strong> Because the request object was deleted <em>before</em> the burn function was called, the subsequent read of <code>request.shares</code> accessed a zeroed-out storage slot. Consequently, the function burned <code>0</code> shares instead of the correct amount.</li>
<li><strong>The Impact:</strong> While users received their funds, the corresponding shares were never destroyed. This would lead to a permanent imbalance between the total share supply and the underlying assets, effectively diluting the protocol's exchange rate and breaking the accounting logic.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.openzeppelin.com/restakefi-audit#shares-not-burned-after-redemption-of-underlying-assets">OpenZeppelin Restake Finance Audit</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-01-16---3"><a class="header" href="#2024-01-16---3">2024-01-16 - 3</a></h2>
<ul>
<li><strong>Date</strong>: 2024-01-16</li>
<li><strong>Project</strong>: Socket (Bungee Bridge)</li>
<li><strong>Value Lost</strong>: ~$3,300,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 2: Access Control Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 2.2.4: Composable Arbitrary Calls</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 2.2.1: Unsafe Token Approvals</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Socket (Bungee) bridge was exploited due to an arbitrary external call vulnerability in a newly deployed route handler.</li>
<li><strong>The Flaw:</strong> The contract's <code>performAction</code> function processed user-supplied <code>swapExtraData</code> without validating the target or the calldata.</li>
<li><strong>The Exploit:</strong> An attacker exploited this by passing the WETH contract address as the target and encoding a <code>transferFrom</code> call in the <code>swapExtraData</code>. Because users had previously granted infinite WETH approvals to the Socket Gateway contract, the contract executed the malicious <code>transferFrom</code> call as a "confused deputy," draining funds from user wallets directly to the attacker.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://rekt.news/socket-rekt/">Rekt News - Socket Rekt</a></li>
<li><a href="https://socketdottech.medium.com/socket-exploit-post-mortem-8d2495d40900">Socket Post-Mortem</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-01-12---2"><a class="header" href="#2024-01-12---2">2024-01-12 - 2</a></h2>
<ul>
<li><strong>Date</strong>: 2024-01-12</li>
<li><strong>Project</strong>: Beanstalk (Immunefi Disclosure)</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Patched)</li>
<li><strong>Chain</strong>: Ethereum</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.1.1: Insufficient Input Validation</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.2.1: Insufficient Oracle Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>: A critical vulnerability was discovered in Beanstalk's "Well" integration (liquidity pools). The protocol failed to validate the <code>Well</code> address provided by a user during liquidity removal. The <code>convert</code> logic trusted the input address to calculate the amount of BEAN tokens to return to the user. Because there was no whitelist or check to ensure the address was a legitimate Beanstalk Well, an attacker could have deployed a malicious contract that acted as a fake Well. This fake contract could report that the attacker was entitled to the entire BEAN balance of the Beanstalk contract, effectively allowing them to drain the silo without holding significant liquidity.</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/immunefi/beanstalk-insufficient-input-validation-bugfix-review-471241940733">Immunefi Bugfix Review</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2024-01-31---1"><a class="header" href="#2024-01-31---1">2024-01-31 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2024-01-31</li>
<li><strong>Project</strong>: Abracadabra</li>
<li><strong>Value Lost</strong>: $6,500,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: BWC 6: Arithmetic &amp; Numeric Vulnerabilities</li>
<li><strong>Primary Classification</strong>: BWC 6.2: Precision Loss &amp; Rounding Errors</li>
<li><strong>Secondary Classification</strong>: BWC 5.2.2: First Deposit / Inflation Attack</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The exploit's root cause was a rounding issue in the CauldronV4 contract's borrow function. An attacker manipulated their share of the total debt by repeatedly borrowing and repaying small amounts of MIM, taking advantage of a rounding error.</li>
<li>This attack was amplified by an ERC-4626 style inflation attack, where the attacker donated MIM to the BentoBox to manipulate the share price after repaying the debt of all other users.</li>
<li>By repeatedly borrowing and repaying, the attacker exponentially increased their share of the debt (<code>part</code>) while keeping the total borrowed assets low. This incorrect debt calculation allowed the attacker to borrow a large amount of MIM with very little collateral, draining the liquidity from the <code>yvCrv3Crypto</code> and <code>magicAPE</code> cauldrons.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0x26a83db7e28838dd9fee6fb7314ae58dcc6aee9a20bf224c386ff5e80f7e4cf2">Attack Tx 1</a></li>
<li><a href="https://etherscan.io/tx/0xdb4616b89ad82062787a4e924d520639791302476484b9a6eca5126f79b6d877">Attack Tx 2</a></li>
<li><a href="https://rekt.news/abra-rekt/">Rekt News Article</a></li>
</ul>
</li>
</ul>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2023-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2023-evm-contract-vulnerability-incidents-classification--analysis">2023 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2023-06-22---1"><a class="header" href="#2023-06-22---1">2023-06-22 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2023-06-22 (Disclosure Date)</li>
<li><strong>Project</strong>: General EIP-2612 Implementations</li>
<li><strong>Value Lost</strong>: $0 (Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: EVM</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 8: Denial of Service (DoS) Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 8.11: DoS via Front-Running (Griefing)</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 5.1.1: Front-Running</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>Security researchers at Trust Security detailed a Denial of Service vector known as "Permit Griefing" affecting contracts integrating EIP-2612.</li>
<li><strong>The Flaw:</strong> Many contracts implement a "multicall" or "permit-then-execute" flow where <code>permit()</code> is called to set token allowances before executing a trade or deposit. The contracts typically expect the <code>permit()</code> call to succeed and will revert the entire transaction if it fails.</li>
<li><strong>The Exploit:</strong> Because the permit signature is visible in the mempool, an attacker can front-run the user's transaction and submit the <code>permit()</code> call themselves. The attacker's transaction succeeds, consuming the user's nonce and granting the approval. However, when the user's transaction subsequently attempts to call <code>permit()</code> with the same (now used) nonce, it reverts. Although the approval exists, the user's intent (the trade or deposit) is blocked.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://www.trust-security.xyz/post/permission-denied">Trust Security: Permission Denied</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2023-12-06---1"><a class="header" href="#2023-12-06---1">2023-12-06 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2023-12-06</li>
<li><strong>Project</strong>: TIME Contract ERC2771 Exploit</li>
<li><strong>Value Lost</strong>: $212,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 4: Input &amp; Data Validation Vulnerabilities</li>
<li>Primary Classification: BWC 4.4.1: ERC-2771 + Multicall</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The TIME contract was exploited due to a vulnerability in its <code>multicall</code> function, which was set as a trusted forwarder for ERC-2771 meta-transactions. The issue stemmed from the <code>multicall</code> function not complying with the ERC-2771 standard for trusted forwarders.</li>
<li><strong>The Flaw:</strong> A compliant trusted forwarder must append the original <code>msg.sender</code> (20 bytes) to the end of the calldata it forwards. The TIME contract's <code>multicall</code> function failed to do this.</li>
<li>
<pre><code class="language-javascript">// Flawed Multicall implementation
function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {
    ...
    (success, returnData[i]) = call.target.call(call.callData); // Fails to append msg.sender
    ...
}
</code></pre>
</li>
<li><strong>The Mechanism:</strong> The <code>ERC2771Context</code> contract, used for handling meta-transactions, retrieves the sender's address by reading the last 20 bytes of the calldata it receives from a trusted forwarder.</li>
<li>
<pre><code class="language-javascript">// ERC2771Context logic to extract sender
function _msgSender() internal view virtual override returns (address sender) {
    if (isTrustedForwarder(msg.sender) &amp;&amp; msg.data.length &gt;= 20) {
        assembly {
            sender := shr(96, calldataload(sub(calldatasize(), 20)))
        }
    } else {
        return super._msgSender();
    }
}
</code></pre>
</li>
<li><strong>The Exploit:</strong> Because the flawed <code>multicall</code> didn't append the real sender, the last 20 bytes of the <em>original calldata provided by the attacker</em> were read by <code>_msgSender</code>. This allowed the attacker to craft a call where the last 20 bytes contained any address they wished to impersonate, such as the contract's owner, thereby bypassing access controls and draining funds.</li>
<li><strong>The Fix:</strong> A secure <code>multicall</code> implementation appends the sender, ensuring the correct address is forwarded.</li>
<li>
<pre><code class="language-javascript">// Secure Multicall3 implementation
function aggregate(Call[] calldata calls) public payable returns (uint256 blockNumber, bytes[] memory returnData) {
    ...
    (success, returnData[i]) = call.target.call(abi.encodePacked(call.callData, msg.sender)); // Correctly appends msg.sender
    ...
}
</code></pre>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://etherscan.io/tx/0xecdd111a60debfadc6533de30fb7f55dc5ceed01dfadd30e4a7ebdb416d2f6b6">Time Exploit </a></li>
<li><a href="https://blog.openzeppelin.com/arbitrary-address-spoofing-vulnerability-erc2771context-multicall-public-disclosure">Openzeppelin ERC2771 disclosure</a></li>
</ul>
</li>
</ul>
<hr />
<h2 id="2023-09-25---1"><a class="header" href="#2023-09-25---1">2023-09-25 - 1</a></h2>
<ul>
<li><strong>Date</strong>: 2023-09-25 (Disclosure Date)</li>
<li><strong>Project</strong>: Multiple Smart Accounts (ERC-1271 Implementations)</li>
<li><strong>Value Lost</strong>: $0 (Critical Vulnerability Disclosure)</li>
<li><strong>Chain</strong>: EVM Chains (Multi-chain)</li>
<li><strong>BWC</strong>:
<ul>
<li><strong>Broader Classification</strong>: <code>BWC 4: Input &amp; Data Validation Vulnerabilities</code></li>
<li><strong>Primary Classification</strong>: <code>BWC 4.3.2: Incomplete Signature Schemes</code></li>
<li><strong>Secondary Classification</strong>: <code>BWC 4.3.1: Missing Signature Validation</code></li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>A widespread vulnerability was identified in the implementation of ERC-1271 <code>isValidSignature</code> across multiple smart account providers.</li>
<li><strong>The Flaw:</strong> The standard implementation often only verified that the signature recovered to the correct <code>owner</code> address. It failed to verify that the signature was intended <em>specifically</em> for the contract instance receiving it.</li>
<li><strong>The Exploit:</strong> If a user deployed multiple smart accounts (e.g., <code>Account A</code> and <code>Account B</code>) controlled by the same EOA key, a valid signature intended for <code>Account A</code> (e.g., a Permit signature) could be replayed on <code>Account B</code> because <code>Account B</code> only checked if the signer was the owner (which was true). This allowed attackers to replay authorizations across different accounts or chains owned by the same user.</li>
<li><strong>Vulnerable Code Pattern:</strong>
<pre><code class="language-solidity">function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {
    // VULNERABLE: Only checks signer identity, not the destination scope
    if (recoverSigner(_hash, _signature) == owner) {
        return 0x1626ba7e;
    } else {
        return 0xffffffff;
    }
}
</code></pre>
</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://mirror.xyz/curiousapple.eth/pFqAdW2LiJ-6S4sg_u1z08k4vK6BCJ33LcyXpnNb8yU">Curious Apple Mirror Post</a></li>
<li><a href="https://www.alchemy.com/blog/erc-1271-replay-vulnerability">Alchemy Security Update</a></li>
</ul>
</li>
</ul>
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2020-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2020-evm-contract-vulnerability-incidents-classification--analysis">2020 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2020-evm-contract-vulnerability-incidents-classification--analysis-1"><a class="header" href="#2020-evm-contract-vulnerability-incidents-classification--analysis-1">2020 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2020-evm-contract-vulnerability-incidents-classification--analysis-2"><a class="header" href="#2020-evm-contract-vulnerability-incidents-classification--analysis-2">2020 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2020-03-12---makerdao-black-thursday"><a class="header" href="#2020-03-12---makerdao-black-thursday">2020-03-12 - MakerDAO Black Thursday</a></h2>
<ul>
<li><strong>Date</strong>: 2020-03-12</li>
<li><strong>Project</strong>: MakerDAO</li>
<li><strong>Value Lost</strong>: $8,300,000</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 5: Economic &amp; Game-Theoretic Vulnerabilities, BWC 1: Ecosystem &amp; Off-Chain Risks</li>
<li>Primary Classification: BWC 5.4.1: Cascade Failure from Network Congestion, BWC 1.3.7: Flawed Off-Chain Infrastructure</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>On "Black Thursday," a massive ETH price drop caused extreme network congestion and gas price spikes on Ethereum.</li>
<li>This led to a cascade of failures in the MakerDAO system:
<ol>
<li><strong>Oracle Lag:</strong> Price oracles failed to update in a timely manner due to the high gas fees.</li>
<li><strong>Mass Liquidations:</strong> When the oracles finally updated with a much lower price, a large number of collateralized debt positions (CDPs) were liquidated simultaneously.</li>
<li><strong>Keeper Failure:</strong> The reference keeper software, used by most auction bidders, was not designed to handle the extreme gas prices and failed to submit bids.</li>
<li><strong>Zero-Bid Auctions:</strong> The lack of competing bids allowed a few liquidators to win collateral auctions with bids of 0 DAI, extracting over $8.3 million worth of ETH for free.</li>
</ol>
</li>
<li>This incident was a systemic failure caused by the protocol's inability to handle extreme market volatility and network congestion, coupled with a critical failure in its off-chain keeper infrastructure.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://consensys.net/blog/news/black-thursday-the-day-defi-died-for-a-bit/">ConsenSys - Black Thursday: The Day DeFi Died (For a Bit)</a></li>
<li><a href="https://insights.glassnode.com/what-really-happened-to-makerdao/">MakerDAO Posrmortem</a></li>
</ul>
</li>
</ul>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2017-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2017-evm-contract-vulnerability-incidents-classification--analysis">2017 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2017-11-06---parity-multi-sig-library-self-destruct"><a class="header" href="#2017-11-06---parity-multi-sig-library-self-destruct">2017-11-06 - Parity Multi-Sig Library Self-Destruct</a></h2>
<ul>
<li><strong>Date</strong>: 2017-11-06</li>
<li><strong>Project</strong>: Parity</li>
<li><strong>Value Lost</strong>: $300,000,000 (approx. 513,774 ETH frozen)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 3: Smart Contract Logic &amp; State Manipulation</li>
<li>Primary Classification: BWC 3.2.1: Improper Initialization</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The Parity multi-signature wallets relied on a single shared library contract for their logic (acting as the implementation for many light proxies).</li>
<li>This library contract was deployed but left uninitialized, meaning it had no owner.</li>
<li>A user (<code>devops199</code>) was able to call the <code>initWallet</code> function on the library contract itself, effectively claiming ownership of the standard library.</li>
<li>The user then triggered the <code>kill()</code> function (Tx: <a href="https://etherscan.io/tx/0x47f7cff7a5e671884629c93b368cb18f58a993f4b19c2a53a8662e3f1482f690">0x47f7...f690</a>), which executed <code>selfdestruct</code>.</li>
<li>The destruction of the library contract rendered all dependent multi-sig wallets non-functional, permanently freezing the funds held within them.</li>
</ul>
</li>
<li><strong>References</strong>:
<ul>
<li><a href="https://medium.com/cybermiles/i-accidentally-killed-it-and-evaporated-300-million-6b975dc1f76b">I accidentally killed it and evaporated $300 million</a></li>
<li><a href="https://parity.io/blog/security-alert-2/">Parity Security Alert</a></li>
</ul>
</li>
</ul>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="2016-evm-contract-vulnerability-incidents-classification--analysis"><a class="header" href="#2016-evm-contract-vulnerability-incidents-classification--analysis">2016 EVM Contract Vulnerability Incidents Classification &amp; Analysis.</a></h1>
<p>This database uses the <a href="skills/bounty-hunting/references/incidents/../../../../README.html">BWC</a> to classify Contract Vulnerability Incidents. Note off-chain issues have been excluded they're the most prevalent and resulted in more values lost. Humans remains to be the weakest point human stupidity or ingenuity(depending on how you look at it) could be infinite. It's unfeasible to track it.</p>
<hr />
<h2 id="2016-06-17---the-dao-hack"><a class="header" href="#2016-06-17---the-dao-hack">2016-06-17 - The DAO Hack</a></h2>
<ul>
<li><strong>Date</strong>: 2016-06-17</li>
<li><strong>Project</strong>: The DAO</li>
<li><strong>Value Lost</strong>: $60,000,000 (approx. 3.6M ETH)</li>
<li><strong>Chain</strong>: Ethereum Mainnet</li>
<li><strong>BWC</strong>:
<ul>
<li>Broader Classification: BWC 3: Smart Contract Logic &amp; State Manipulation</li>
<li>Primary Classification: BWC 3.1.1: Standard Reentrancy</li>
</ul>
</li>
<li><strong>Description</strong>:
<ul>
<li>The DAO smart contract contained a critical reentrancy vulnerability in its <code>splitDAO</code> function.</li>
<li>The contract logic performed an external call to send Ether to the user <em>before</em> updating the user's internal balance (or share count).</li>
<li>The attacker deployed a malicious contract with a fallback function. When The DAO contract sent ETH to this malicious contract, the fallback function triggered, recursively calling the <code>splitDAO</code> function again.</li>
<li>Since the state (balance) hadn't been updated yet, the subsequent calls were also successful, allowing the attacker to drain funds repeatedly in a single transaction stack.</li>
<li>This event led to the controversial hard fork that created Ethereum (ETH) and Ethereum Classic (ETC).</li>
</ul>
</li>
</ul>
<h3 id="vulnerable-code-pattern"><a class="header" href="#vulnerable-code-pattern">Vulnerable Code Pattern</a></h3>
<pre><code class="language-solidity">// Simplified representation of the vulnerability
mapping(address =&gt; uint) public balances;

function withdraw() public {
    uint amount = balances[msg.sender];
    
    // Check
    require(amount &gt; 0);

    // Interaction (Vulnerability: External call before state update)
    (bool sent, ) = msg.sender.call{value: amount}("");
    require(sent, "Failed to send Ether");

    // Effect
    balances[msg.sender] = 0;
}
</code></pre>
<ul>
<li><strong>References</strong>:
<ul>
<li><a href="https://blog.chain.link/reentrancy-attacks-and-the-dao-hack/">Chainlink - Reentrancy Attacks and The DAO Hack</a></li>
<li><a href="https://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/">Phil Daian - Analysis of the DAO exploit</a></li>
</ul>
</li>
</ul>
<hr />
<p>Itâ€™s important to emphasize that the intent behind this content is not to criticize or blame the affected projects but to provide objective overviews that serve as educational material for the community to learn from and better protect projects in the future.</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="services-agreement-template-for-a-smart-contract-audit"><a class="header" href="#services-agreement-template-for-a-smart-contract-audit">Services Agreement Template for a Smart Contract Audit</a></h1>
<p>This Services Agreement ("Agreement") is entered into between [Client Name], hereinafter referred to as "Client," and [Auditor Name], hereinafter referred to as "Auditor," collectively referred to as the "Parties."</p>
<h2 id="1-scope-of-work"><a class="header" href="#1-scope-of-work">1. Scope of Work</a></h2>
<p>The Auditor agrees to perform a security audit of the Client's smart contracts deployed on [blockchain network], specifically [list contract addresses or repository links]. The audit will assess the code for vulnerabilities, logic errors, and compliance with industry best practices.</p>
<h2 id="2-audit-process"><a class="header" href="#2-audit-process">2. Audit Process</a></h2>
<ul>
<li>Initial Review: The Auditor will perform an initial assessment of the smart contract code and share preliminary findings.</li>
<li>Client Feedback: The Client may address the findings and implement fixes based on the initial review.</li>
<li>Final Review: The Auditor will review the updated code and prepare a final audit report.</li>
<li>Report Delivery: The final report will detail vulnerabilities, recommendations, and an overall security assessment.</li>
</ul>
<h2 id="3-timeline"><a class="header" href="#3-timeline">3. Timeline</a></h2>
<p>The audit will begin on [start date] and is expected to conclude by [end date], with the final report delivered by [report delivery date]. The Auditor is available to work from the 1st to the 21st of each month, dedicating 12 hours per day, 7 days a week, for a total of 21 consecutive days.</p>
<h2 id="4-pricing-and-payment-terms"><a class="header" href="#4-pricing-and-payment-terms">4. Pricing and Payment Terms</a></h2>
<h3 id="41-pricing-formula"><a class="header" href="#41-pricing-formula">4.1 Pricing Formula</a></h3>
<p>The total fee for the audit is calculated based on the number of Solidity lines of code (SLOC), determined using the following method:</p>
<ul>
<li>Code Formatting:
The Solidity code must be formatted using forge fmt with the following settings:
<pre><code class="language-bash"> export FOUNDRY_FMT_SINGLE_LINE_STATEMENT_BLOCKS="multi"
 export FOUNDRY_FMT_LINE_LENGTH=90
 export FOUNDRY_FMT_TAB_WIDTH=4
 export FOUNDRY_FMT_MULTILINE_FUNC_HEADER="params_first_multi"
 export FOUNDRY_FMT_BRACKET_SPACING=false
 export FOUNDRY_FMT_INT_TYPES="long"
 export FOUNDRY_FMT_QUOTE_STYLE="double"
 export FOUNDRY_FMT_NUMBER_UNDERSCORE="thousands"
 export FOUNDRY_FMT_HEX_UNDERSCORE="remove"
 export FOUNDRY_FMT_OVERRIDE_SPACING=false
 export FOUNDRY_FMT_WRAP_COMMENTS=false
 export FOUNDRY_FMT_CONTRACT_NEW_LINES=true
 export FOUNDRY_FMT_SORT_IMPORTS=true
</code></pre>
</li>
<li>Counting Lines of Code:
After formatting, the SLOC will be calculated using cloc, a GNU utility, based on its output for Solidity files.</li>
<li>The total fee is determined by the formula:</li>
</ul>
<p><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord">Â </span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mord mathnormal">ee</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.8em;vertical-align:-0.65em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9322em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">200</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mbin mtight">Ã—</span><span class="mord text mtight"><span class="mord mtight">testingÂ factor</span></span></span></span></span></span><span class="vlist-s">â€‹</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">12</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">Ã—</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">200</span><span class="mord text"><span class="mord">Â USD</span></span></span></span></span></p>
<p>Where:</p>
<ul>
<li>
<p>( a ) = SLOC, as calculated by cloc after formatting with forge fmt using the settings above.</p>
</li>
<li>
<p>Testing factor = 2 (if the Client provides tests) or 3 (if the Auditor must write tests for Proof of Concept (POC)).</p>
</li>
<li>
<p>Audit Time: The adjusted SLOC (after applying the testing factor) is divided by 200 (assuming the Auditor audits 200 SLOC per hour).</p>
</li>
<li>
<p>Report Compilation: An additional 12 hours is added for compiling the audit report and quality-of-life (QOL) documentation.</p>
</li>
<li>
<p>Hourly Rate: The total hours are multiplied by the Auditorâ€™s rate of {200 USD} per hour.</p>
</li>
</ul>
<h3 id="42-deposit"><a class="header" href="#42-deposit">4.2 Deposit</a></h3>
<p>The Client shall pay a 30% non-refundable deposit of the estimated total fee upon signing this Agreement. The estimate will be based on an initial SLOC count provided by the Client.</p>
<h3 id="43-final-payment"><a class="header" href="#43-final-payment">4.3 Final Payment</a></h3>
<p>The final payment will be adjusted based on the actual SLOC count at the time of the audit and is due upon delivery of the final audit report.</p>
<h3 id="44-payment-method"><a class="header" href="#44-payment-method">4.4 Payment Method</a></h3>
<p>Payments shall be made in [cryptocurrency, e.g., ETH, USDC] to the Auditorâ€™s wallet address [wallet address].</p>
<h3 id="45-late-payments"><a class="header" href="#45-late-payments">4.5 Late Payments</a></h3>
<p>Late payments will incur interest at [rate] per [time period].</p>
<h2 id="5-responsibilities"><a class="header" href="#5-responsibilities">5. Responsibilities</a></h2>
<p>Client Responsibilities:</p>
<ul>
<li>Provide the final commit of the smart contracts by [date].</li>
<li>Indicate whether tests are provided or if the Auditor must write tests for POC.</li>
<li>Be available for meetings and discussions as required.</li>
<li>Implement recommended fixes from the audit findings.</li>
</ul>
<p>Auditor Responsibilities:</p>
<ul>
<li>Perform the audit with professionalism and diligence.</li>
<li>Deliver a comprehensive final report by the agreed delivery date.</li>
<li>Maintain confidentiality of the Clientâ€™s information.</li>
</ul>
<h2 id="6-changes-and-unforeseen-circumstances"><a class="header" href="#6-changes-and-unforeseen-circumstances">6. Changes and Unforeseen Circumstances</a></h2>
<ul>
<li>
<p>Scope Changes: Any changes to the scope must be agreed in writing and may adjust the timeline and fees. New functionality added during the fix audit may incur additional costs.</p>
</li>
<li>
<p>Auditor Unavailability: If the Auditor cannot perform the audit due to unforeseen circumstances, a qualified replacement will be provided, or the timeline will be adjusted.</p>
</li>
<li>
<p>Client Delays: If the Client is not ready by the start date, the Auditor may reschedule or charge additional fees.</p>
</li>
<li>
<p>SLOC Disputes: Any disagreements over the SLOC count will be resolved by re-running cloc on the code formatted with the specified forge fmt settings.</p>
</li>
</ul>
<h2 id="7-intellectual-property"><a class="header" href="#7-intellectual-property">7. Intellectual Property</a></h2>
<p>The Auditor retains ownership of any tools, methodologies, or concepts developed during the audit, unless otherwise agreed.</p>
<h2 id="8-liability-limitations"><a class="header" href="#8-liability-limitations">8. Liability Limitations</a></h2>
<p>The Auditor is not liable for undetected vulnerabilities or exploits after the audit. The Client understands that the audit is a point-in-time evaluation and does not ensure absolute security.</p>
<h2 id="9-cancellation-policy"><a class="header" href="#9-cancellation-policy">9. Cancellation Policy</a></h2>
<p>The Client may cancel with at least 7 daysâ€™ notice, forfeiting the deposit. Cancellations with less than 7 daysâ€™ notice will incur a fee of 50% of the estimated total fee.
The Auditor may cancel if the Client fails to meet their obligations, with the deposit remaining non-refundable.</p>
<h2 id="10-dispute-resolution"><a class="header" href="#10-dispute-resolution">10. Dispute Resolution</a></h2>
<p>Disputes arising from this Agreement will be resolved through [mediation, arbitration, or jurisdiction-specific legal process].</p>
<h2 id="11-compliance-and-legal-framework"><a class="header" href="#11-compliance-and-legal-framework">11. Compliance and Legal Framework</a></h2>
<p>The Client confirms that all funds used for payment are from legitimate sources and comply with anti-money laundering (AML) regulations.
The Auditor may require the Client to complete know-your-business (KYB) procedures before starting the audit.
Both Parties agree to adhere to applicable laws and regulations.</p>
<h2 id="12-miscellaneous"><a class="header" href="#12-miscellaneous">12. Miscellaneous</a></h2>
<p>Confidentiality: Both Parties will protect sensitive information shared during the engagement.
Report Publication: The Auditor may publish the audit report after 30 days from delivery, unless the Client objects in writing.
Governing Law: This Agreement is governed by the laws of [jurisdiction].</p>
<h2 id="13-signatures"><a class="header" href="#13-signatures">13. Signatures</a></h2>
<p>By signing below, both Parties confirm they have read, understood, and agree to be bound by this Agreement.</p>
<p>[Client Signature]
[Date]
[Auditor Signature]
[Date]</p>

                        </div>
                        <div id="sidetoc">
                            <nav id="pagetoc"></nav>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>
        <script src="theme/collapsible.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

        <!-- Back to Top Button -->
        <button id="back-to-top" title="Go to Top">
            <i class="fa fa-arrow-up"></i>
        </button>

    </div>
    </body>
</html>
